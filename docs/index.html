<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>LiteratePT</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <link rel="stylesheet" href="theme.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
  <!-- pandoc-eqnos: equation style -->
  <style>
    .eqnos { display: inline-block; position: relative; width: 100%; }
    .eqnos br { display: none; }
    .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">LiteratePT</h1>
<p class="subtitle">a translation of smallpt</p>
<!--        <div id="dark-mode-toggle">
                <p>Dark mode: <button class="dark-mode-button"
                        aria-label="Toggle dark mode"
                        onclick="toggle_dark_mode()">
                        <span></span><span></span>
                </button></p>
</div> -->
</header>
<div class="row">
        <div class="col-6 col-s-9" id="main">
<section id="literatept" class="level1">
<h1>LiteratePT</h1>
<p>One of my favourite compute science books is <a href="https://pbrt.org/">“Physically Based Rendering” by Matt Pharr, Wenzel Jakob and Greg Humphreys (PBRT)</a>. For me, this book put the concept of Literate Programming on the map, as well as giving an awesome overview of the technologies that go into graphics rendering. Now PBRT is more than 1200 pages, so I thought what better than to create a tribute of some smaller size?</p>
<p>Over time, there have been developed some ray-tracers of truly miniscule size. It is amazing how much you can do in little code. For me the most clear example is <a href="https://www.kevinbeason.com/smallpt/">SmallPT</a> by Kevin Beason. SmallPT is a global illumination ray tracer in 100 lines of C++.</p>
<figure>
<img src="img/image.png" style="width:100%" alt="10000 spp rendering" /><figcaption aria-hidden="true">10000 spp rendering</figcaption>
</figure>
<p>This is a translation into Rust; not in a 100 lines, but like PBRT, extremely literate. The entirety of this implementation is contained in a single Markdown file. To extract the source code, you may use <a href="https://entangled.github.io/">Entangled</a>, or to render the published version, use <a href="https://pandoc.org/">Pandoc</a>. All the math and equations are explained, and I’ve tried to explain some concepts in Rust.</p>
<section id="todo" class="level2">
<h2>TODO</h2>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
Explain the sub-pixel sampling</li>
<li><input type="checkbox" disabled="" />
Explain use of Rayon in <code>Image::for_each</code></li>
<li><input type="checkbox" disabled="" checked="" />
Explain <code>RGBColour</code> structure</li>
<li><input type="checkbox" disabled="" checked="" />
Add command-line interface</li>
<li><input type="checkbox" disabled="" checked="" />
Fix performance issues with writing output</li>
<li><input type="checkbox" disabled="" checked="" />
Add proper progress bar</li>
<li><input type="checkbox" disabled="" checked="" />
Simplify recursion pattern</li>
</ul>
</section>
<section id="getting-started-with-rust" class="level2">
<h2>Getting started with Rust</h2>
<p>The easiest way to install the Rust compiler is through the <a href="https://rustup.rs/"><code>rustup</code> command</a>. This will install both the Rust compiler <code>rustc</code> and its accompanying package manager <code>cargo</code>. You’d normally start a new project by running <code>cargo init</code>. This command creates the skeleton structure of a Rust project: a <code>Cargo.toml</code> and a “Hello World” program in <code>src/main.rs</code>. Since my goal is to have everything in a single Markdown file, I include the <code>Cargo.toml</code> here:</p>
<div class="named-code-block">
<p>file:Cargo.toml</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">package</span><span class="kw">]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">name</span> <span class="op">=</span> <span class="st">&quot;literatept&quot;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">version</span> <span class="op">=</span> <span class="st">&quot;0.2.0&quot;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">authors</span> <span class="op">=</span> <span class="op">[</span><span class="st">&quot;Johan Hidding &lt;j.hidding@esciencecenter.nl&gt;&quot;</span><span class="op">]</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">edition</span> <span class="op">=</span> <span class="st">&quot;2018&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">profile</span><span class="kw">.</span><span class="dt">release</span><span class="kw">]</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">opt-level</span> <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dt">debug</span> <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dt">strip</span> <span class="op">=</span> <span class="st">&quot;debuginfo&quot;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">dependencies</span><span class="kw">]</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="er">&lt;&lt;dependencies&gt;&gt;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">dev-dependencies</span><span class="kw">]</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="er">&lt;&lt;dev-dependencies&gt;&gt;</span></span></code></pre></div>
</div>
<p>Now, if I want to introduce some features to this program that require external packages (called <em>crates</em> in Rust), I can do so by extending on the <code>&lt;&lt;dependencies&gt;&gt;</code> section. For example, I will need a random number generator. This is most commonly available in the <code>rand</code> crate: <!-- > The package description can be extended using [more keys and their definitions](https://doc.rust-lang.org/cargo/reference/manifest.html) --></p>
<div class="named-code-block">
<p>«dependencies»</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">rand</span> <span class="op">=</span> <span class="st">&quot;0.8.5&quot;</span></span></code></pre></div>
</div>
</section>
<section id="outline" class="level2">
<h2>Outline</h2>
<p>Everything about graphics rendering happens in a three-dimensional world, so I will need to explain some of the <a href="#vectors">vector mathematics</a> that we’re using. In SmallPT, the <code>vec3</code> type is then doubling up as a type for <a href="#colours">colours</a>. Since we’re not trying to be minimal here, I will treat colours entirely separately from vector algebra. After this ground work, we need to implement some <a href="#geometry">geometry primitives</a>: spheres, rays and how they intersect. When we have that, we can describe a <a href="#scene">scene</a>. The SmallPT scene is a modification of the Cornell box, that consists solely of spheres, some so large that they appear as a nearly flat surface.</p>
<p>This all leads up to the core of the matter: <a href="#path-tracing">path tracing</a>. How do we model every possible path that a beam of light can take to arrive in our camera?</p>
<p>The program is not complete before we write a <a href="#main">main function</a>, including code to write the image to a PPM file, and some user interaction: command-line arguments and a friendly progress bar.</p>
<div class="named-code-block">
<p>«dependencies»</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">rayon</span> <span class="op">=</span> <span class="st">&quot;1.5.3&quot;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">indicatif</span> <span class="op">=</span> <span class="op">{ </span><span class="dt">version</span><span class="op"> =</span> <span class="st">&quot;0.16.2&quot;</span><span class="op">, </span><span class="dt">features</span><span class="op"> =</span> <span class="op">[</span><span class="st">&quot;rayon&quot;</span><span class="op">]</span> <span class="op">}</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dt">argh</span> <span class="op">=</span> <span class="st">&quot;0.1.7&quot;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«imports»</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="kw">crate</span> rayon<span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">rayon::prelude::</span><span class="op">*;</span></span></code></pre></div>
</div>
</section>
</section>
<section id="vectors" class="level1">
<h1>Vectors</h1>
<p><span class="math inline">\(\renewcommand{\vec}[1]{{\bf #1}}\)</span> The use of three-component vectors is ubiquitous in this little program.</p>
<div class="named-code-block">
<p>file:src/vec3.rs</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>vector<span class="op">&gt;&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">mod</span> tests <span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="kw">super</span><span class="pp">::</span><span class="op">*;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">quickcheck::</span><span class="op">*;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>vector<span class="op">-</span>tests<span class="op">&gt;&gt;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>The <code>Vec3</code> type has three public members <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> and <span class="math inline">\(z\)</span>. We define the <code>struct</code> and a short-hand helper function <code>vec</code>.</p>
<div class="named-code-block">
<p>«vector»</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Clone</span><span class="op">,</span><span class="bu">Copy</span><span class="op">,</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">struct</span> Vec3 <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> x<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> y<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> z<span class="op">:</span> <span class="dt">f64</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const</span> <span class="kw">fn</span> vec(x<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> y<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> z<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> Vec3 <span class="op">{</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    Vec3 <span class="op">{</span> x<span class="op">:</span> x<span class="op">,</span> y<span class="op">:</span> y<span class="op">,</span> z<span class="op">:</span> z <span class="op">}</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>We derive the <code>Clone</code>, <code>Copy</code>, and <code>Debug</code> traits, meaning that we can print debug statements involving <code>Vec3</code> instances, and that we can clone instances usinge the <code>.clone()</code> method. The <code>Copy</code> trait means that the <code>Vec3</code> can be copied implicitly, creating call-by-value semantics on this type.</p>
<section id="why-not-a-class" class="level3 alert alert-info">
<h3>Why not a class?</h3>
<p>Rust doesn’t have classes. Instead, you define a <code>struct</code> with the data elements, and then implement one or more <code>trait</code>s on top of that. Data hiding, access patterns, inheritance and what-have-you-not in object-oriented styles of programming can still be achieved using <code>trait</code>s. For more information, see <a href="https://doc.rust-lang.org/book/ch17-00-oop.html">The Rust Book, chapter 17</a>.</p>
</section>
<section id="operators" class="level2">
<h2>Operators</h2>
<p>Each of the overloaded operators only occupy a single line of code in SmallPt, but this is probably better. Rust has a trait for every standard operator in the language. These operators are syntactic sugar for the relevant function calls in each trait. Here we define <code>+</code>, and <code>-</code> (both unary and binary forms).</p>
<div class="named-code-block">
<p>«vector»</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Add</span> <span class="kw">for</span> Vec3 <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> add(<span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> <span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span> <span class="op">{</span> x<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>x <span class="op">+</span> other<span class="op">.</span>x</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>             <span class="op">,</span> y<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>y <span class="op">+</span> other<span class="op">.</span>y</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>             <span class="op">,</span> z<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>z <span class="op">+</span> other<span class="op">.</span>z <span class="op">}</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Sub</span> <span class="kw">for</span> Vec3 <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> sub(<span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> <span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span> <span class="op">{</span> x<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>x <span class="op">-</span> other<span class="op">.</span>x</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>             <span class="op">,</span> y<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>y <span class="op">-</span> other<span class="op">.</span>y</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>             <span class="op">,</span> z<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>z <span class="op">-</span> other<span class="op">.</span>z <span class="op">}</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Neg</span> <span class="kw">for</span> Vec3 <span class="op">{</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> neg(<span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span><span class="pp">::</span>Output <span class="op">{</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span> <span class="op">{</span> x<span class="op">:</span> <span class="op">-</span><span class="kw">self</span><span class="op">.</span>x<span class="op">,</span> y<span class="op">:</span> <span class="op">-</span><span class="kw">self</span><span class="op">.</span>y<span class="op">,</span> z<span class="op">:</span> <span class="op">-</span><span class="kw">self</span><span class="op">.</span>z <span class="op">}</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>SmallPt defines four kinds of multiplication: scaling, point-wise multiplication, dot product and outer product. The point-wise multiplication is only used to manipulate colors, for which we’ll use separate structures.</p>
<p>Here’s scaling,</p>
<div class="named-code-block">
<p>«vector»</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Mul</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span> <span class="kw">for</span> Vec3 <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> mul(<span class="kw">self</span><span class="op">,</span> s<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span> <span class="op">{</span> x<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>x <span class="op">*</span> s</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>             <span class="op">,</span> y<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>y <span class="op">*</span> s</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>             <span class="op">,</span> z<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>z <span class="op">*</span> s <span class="op">}</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>the dot-product,</p>
<p><span class="math display">\[\vec{a} \cdot \vec{b} = a_x b_x + a_y b_y + a_z b_z\]</span></p>
<div class="named-code-block">
<p>«vector»</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Mul</span><span class="op">&lt;</span>Vec3<span class="op">&gt;</span> <span class="kw">for</span> Vec3 <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">f64</span><span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> mul(<span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> <span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>x <span class="op">*</span> other<span class="op">.</span>x <span class="op">+</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>y <span class="op">*</span> other<span class="op">.</span>y <span class="op">+</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>z <span class="op">*</span> other<span class="op">.</span>z</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>and outer product for which we abuse the <code>%</code> operator,</p>
<p><span class="math display">\[\vec{a} \wedge \vec{b} = \det \begin{pmatrix}
\hat{x} &amp; \hat{y} &amp; \hat{z}\\
a_x &amp; a_y &amp; a_z \\
b_x &amp; b_y &amp; b_z
\end{pmatrix}\]</span></p>
<div class="named-code-block">
<p>«vector»</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Rem</span> <span class="kw">for</span> Vec3 <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> rem(<span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> <span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span> <span class="op">{</span> x<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>y <span class="op">*</span> other<span class="op">.</span>z <span class="op">-</span> <span class="kw">self</span><span class="op">.</span>z <span class="op">*</span> other<span class="op">.</span>y</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>             <span class="op">,</span> y<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>z <span class="op">*</span> other<span class="op">.</span>x <span class="op">-</span> <span class="kw">self</span><span class="op">.</span>x <span class="op">*</span> other<span class="op">.</span>z</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>             <span class="op">,</span> z<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>x <span class="op">*</span> other<span class="op">.</span>y <span class="op">-</span> <span class="kw">self</span><span class="op">.</span>y <span class="op">*</span> other<span class="op">.</span>x <span class="op">}</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>Vectors can be normalized to a unit-vector.</p>
<div class="named-code-block">
<p>«vector»</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Vec3 <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> abs(<span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">self</span> <span class="op">*</span> <span class="kw">self</span>)<span class="op">.</span>sqrt()</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> normalize(<span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span> <span class="op">*</span> (<span class="dv">1.0</span> <span class="op">/</span> <span class="kw">self</span><span class="op">.</span>abs())</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</section>
<section id="tests" class="level2">
<h2>Tests</h2>
<p>We use the <code>quickcheck</code> crate to do some property testing on the <code>Vec3</code> type. The idea of property testing is that you define some properties (duh!) on a type that should always hold. Then, if you have a way to generate arbitrary elements of your type, you can see if these properties do indeed hold. In many cases where mathematics or physics is involved, these test are expressed in much cleaner code than the usual unit tests.</p>
<div class="named-code-block">
<p>«dev-dependencies»</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">quickcheck</span> <span class="op">=</span> <span class="st">&quot;1.0.3&quot;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="dt">quickcheck_macros</span> <span class="op">=</span> <span class="st">&quot;1.0.0&quot;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«import-quickcheck»</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="kw">crate</span> quickcheck<span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>macro_use<span class="at">(</span>quickcheck<span class="at">)]</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="kw">crate</span> quickcheck_macros<span class="op">;</span></span></code></pre></div>
</div>
<p>We need to be able to generate <code>Arbitrary</code> instances of <code>Vec</code>. I’m not sure if this will ever yield a zero-vector, or a sequence of vectors that lie in the same plane. We do want to check our properties on reasonable numbers though.</p>
<div class="named-code-block">
<p>«vector-tests»</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Arbitrary <span class="kw">for</span> Vec3 <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> arbitrary(g<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Gen) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="dt">f64</span><span class="pp">::</span>arbitrary(g)<span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> y <span class="op">=</span> <span class="dt">f64</span><span class="pp">::</span>arbitrary(g)<span class="op">;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> z <span class="op">=</span> <span class="dt">f64</span><span class="pp">::</span>arbitrary(g)<span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        vec(x<span class="op">,</span> y<span class="op">,</span> z)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Vec3 <span class="op">{</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> is_finite(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>x<span class="op">.</span>is_finite() <span class="op">&amp;&amp;</span> <span class="kw">self</span><span class="op">.</span>y<span class="op">.</span>is_finite() <span class="op">&amp;&amp;</span> <span class="kw">self</span><span class="op">.</span>z<span class="op">.</span>is_finite()</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> reasonable(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>is_finite() <span class="op">&amp;&amp;</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>x<span class="op">.</span>log2()<span class="op">.</span>abs() <span class="op">&lt;</span> <span class="dv">16.0</span> <span class="op">&amp;&amp;</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>y<span class="op">.</span>log2()<span class="op">.</span>abs() <span class="op">&lt;</span> <span class="dv">16.0</span> <span class="op">&amp;&amp;</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>z<span class="op">.</span>log2()<span class="op">.</span>abs() <span class="op">&lt;</span> <span class="dv">16.0</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>Now we can check that for any vectors <span class="math inline">\(\vec{a}\)</span> and <span class="math inline">\(\vec{b}\)</span>, we have,</p>
<p><span class="math display">\[(\vec{a} \wedge \vec{b}) \cdot \vec{a} = 0,\]</span></p>
<div class="named-code-block">
<p>«vector-tests»</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>quickcheck<span class="at">]</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> outer_product_orthogonal(a<span class="op">:</span> Vec3<span class="op">,</span> b<span class="op">:</span> Vec3) <span class="op">-&gt;</span> TestResult <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">!</span>(a<span class="op">.</span>reasonable() <span class="op">&amp;&amp;</span> b<span class="op">.</span>reasonable()) <span class="op">{</span> <span class="kw">return</span> <span class="pp">TestResult::</span>discard()<span class="op">;</span> <span class="op">}</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> c <span class="op">=</span> a <span class="op">%</span> b<span class="op">;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">TestResult::</span>from_bool((a <span class="op">*</span> c)<span class="op">.</span>abs() <span class="op">&lt;</span> <span class="dv">1e-6</span> <span class="op">&amp;&amp;</span> (b <span class="op">*</span> c)<span class="op">.</span>abs() <span class="op">&lt;</span> <span class="dv">1e-6</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>that any normalized vector has length 1,</p>
<div class="named-code-block">
<p>«vector-tests»</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>quickcheck<span class="at">]</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> normalized_vec_length(a<span class="op">:</span> Vec3) <span class="op">-&gt;</span> TestResult <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">!</span>a<span class="op">.</span>reasonable() <span class="op">||</span> (a <span class="op">*</span> a) <span class="op">&lt;=</span> <span class="dv">0.0</span> <span class="op">{</span> <span class="kw">return</span> <span class="pp">TestResult::</span>discard()<span class="op">;</span> <span class="op">}</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> b <span class="op">=</span> a<span class="op">.</span>normalize()<span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">TestResult::</span>from_bool((<span class="dv">1.0</span> <span class="op">-</span> b <span class="op">*</span> b)<span class="op">.</span>abs() <span class="op">&lt;</span> <span class="dv">1e-6</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>and that the outer product upholds anti-symmetry,</p>
<p><span class="math display">\[\vec{a} \wedge \vec{b} = - \vec{b} \wedge \vec{a}.\]</span></p>
<div class="named-code-block">
<p>«vector-tests»</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>quickcheck<span class="at">]</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> outer_product_anti_symmetry(a<span class="op">:</span> Vec3<span class="op">,</span> b<span class="op">:</span> Vec3) <span class="op">-&gt;</span> TestResult <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">!</span>(a<span class="op">.</span>reasonable() <span class="op">&amp;&amp;</span> b<span class="op">.</span>reasonable()) <span class="op">{</span> <span class="kw">return</span> <span class="pp">TestResult::</span>discard()<span class="op">;</span> <span class="op">}</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> c <span class="op">=</span> a <span class="op">%</span> b<span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> d <span class="op">=</span> b <span class="op">%</span> a<span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">TestResult::</span>from_bool((c <span class="op">+</span> d)<span class="op">.</span>abs() <span class="op">&lt;</span> <span class="dv">1e-6</span>)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</section>
</section>
<section id="colours" class="level1">
<h1>Colours</h1>
<p>A colour on a computer is described by three numbers: red, green and blue intensity. There is a lot more interesting things to say about colour profiles, gamuts, CMYX, CIELAB or plain RGB encoding, but what it boils down to is the following: in the end we want RGB to store. So we may define a colour to be anything that converts to RGB.</p>
<div class="named-code-block">
<p>file:src/colour.rs</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>inline<span class="at">]</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> clamp(x<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">f64</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> </span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> x <span class="op">&lt;</span> <span class="dv">0</span><span class="op">.</span> <span class="op">{</span> <span class="dv">0</span><span class="op">.</span> <span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span> x <span class="op">&gt;</span> <span class="dv">1</span><span class="op">.</span> <span class="op">{</span> <span class="dv">1</span><span class="op">.</span> <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> x <span class="op">}</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">trait</span> Colour<span class="op">:</span> <span class="bu">Sized</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> <span class="pp">std::ops::</span><span class="bu">Add</span><span class="op">&lt;</span>Output<span class="op">=</span><span class="dt">Self</span><span class="op">&gt;</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> <span class="pp">std::ops::</span><span class="bu">Mul</span><span class="op">&lt;</span>Output<span class="op">=</span><span class="dt">Self</span><span class="op">&gt;</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> <span class="pp">std::ops::</span><span class="bu">Mul</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">,</span> Output<span class="op">=</span><span class="dt">Self</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> to_rgb(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> (<span class="dt">f64</span><span class="op">,</span> <span class="dt">f64</span><span class="op">,</span> <span class="dt">f64</span>)<span class="op">;</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> clamp(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> max(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (r<span class="op">,</span> g<span class="op">,</span> b) <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>to_rgb()<span class="op">;</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> r <span class="op">&gt;</span> g <span class="op">&amp;&amp;</span> r <span class="op">&gt;</span> b <span class="op">{</span> r <span class="op">}</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">if</span> g <span class="op">&gt;</span> b <span class="op">{</span> g <span class="op">}</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="op">{</span> b <span class="op">}</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> to_u24(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> (<span class="dt">u8</span><span class="op">,</span> <span class="dt">u8</span><span class="op">,</span> <span class="dt">u8</span>) <span class="op">{</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> to_int <span class="op">=</span> <span class="op">|</span>x<span class="op">|</span> (clamp(x)<span class="op">.</span>powf(<span class="dv">1</span><span class="op">./</span><span class="dv">2.2</span>) <span class="op">*</span> <span class="dv">255</span><span class="op">.</span> <span class="op">+</span> <span class="dv">0.5</span>)<span class="op">.</span>floor() <span class="kw">as</span> <span class="dt">u8</span><span class="op">;</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (r<span class="op">,</span> g<span class="op">,</span> b) <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>to_rgb()<span class="op">;</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>        (to_int(r)<span class="op">,</span> to_int(g)<span class="op">,</span> to_int(b))</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>We can (and will) have a simple implementation in terms of a three-tuple of <code>f64</code>.</p>
<div class="named-code-block">
<p>«colour»</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Clone</span><span class="op">,</span><span class="bu">Copy</span><span class="op">,</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">struct</span> RGBColour (<span class="dt">f64</span><span class="op">,</span> <span class="dt">f64</span><span class="op">,</span> <span class="dt">f64</span>)<span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const</span> <span class="kw">fn</span> rgb(r<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> g<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> b<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> RGBColour <span class="op">{</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    RGBColour (r<span class="op">,</span> g<span class="op">,</span> b)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Colour <span class="kw">for</span> RGBColour <span class="op">{</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> to_rgb(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> (<span class="dt">f64</span><span class="op">,</span> <span class="dt">f64</span><span class="op">,</span> <span class="dt">f64</span>) <span class="op">{</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> RGBColour(r<span class="op">,</span> g<span class="op">,</span> b) <span class="op">=</span> <span class="kw">self</span><span class="op">;</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        (<span class="op">*</span>r<span class="op">,</span> <span class="op">*</span>g<span class="op">,</span> <span class="op">*</span>b)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> clamp(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> RGBColour(r<span class="op">,</span> g<span class="op">,</span> b) <span class="op">=</span> <span class="kw">self</span><span class="op">;</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>        RGBColour(clamp(<span class="op">*</span>r)<span class="op">,</span> clamp(<span class="op">*</span>g)<span class="op">,</span> clamp(<span class="op">*</span>b))</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<section id="constants" class="level2">
<h2>Constants</h2>
<p>The two most important colours are black and white:</p>
<div class="named-code-block">
<p>«colour»</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const</span> BLACK<span class="op">:</span> RGBColour <span class="op">=</span> rgb(<span class="dv">0.0</span><span class="op">,</span> <span class="dv">0.0</span><span class="op">,</span> <span class="dv">0.0</span>)<span class="op">;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const</span> WHITE<span class="op">:</span> RGBColour <span class="op">=</span> rgb(<span class="dv">1.0</span><span class="op">,</span> <span class="dv">1.0</span><span class="op">,</span> <span class="dv">1.0</span>)<span class="op">;</span></span></code></pre></div>
</div>
</section>
<section id="operators-1" class="level2">
<h2>Operators</h2>
<p>Furthermore, we need to add subtract and multiply colours. For colours it makes most sense to have point-wise multiplication.</p>
<div class="named-code-block">
<p>«colour»</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Add</span> <span class="kw">for</span> RGBColour <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> add(<span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> <span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> RGBColour(r1<span class="op">,</span>g1<span class="op">,</span>b1) <span class="op">=</span> <span class="kw">self</span><span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> RGBColour(r2<span class="op">,</span>g2<span class="op">,</span>b2) <span class="op">=</span> other<span class="op">;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        RGBColour(r1<span class="op">+</span>r2<span class="op">,</span>g1<span class="op">+</span>g2<span class="op">,</span>b1<span class="op">+</span>b2)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Mul</span> <span class="kw">for</span> RGBColour <span class="op">{</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> mul(<span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> <span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> RGBColour(r1<span class="op">,</span>g1<span class="op">,</span>b1) <span class="op">=</span> <span class="kw">self</span><span class="op">;</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> RGBColour(r2<span class="op">,</span>g2<span class="op">,</span>b2) <span class="op">=</span> other<span class="op">;</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>        RGBColour(r1<span class="op">*</span>r2<span class="op">,</span>g1<span class="op">*</span>g2<span class="op">,</span>b1<span class="op">*</span>b2)</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Mul</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span> <span class="kw">for</span> RGBColour <span class="op">{</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> mul(<span class="kw">self</span><span class="op">,</span> s<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> RGBColour(r1<span class="op">,</span>g1<span class="op">,</span>b1) <span class="op">=</span> <span class="kw">self</span><span class="op">;</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>        RGBColour(r1<span class="op">*</span>s<span class="op">,</span>g1<span class="op">*</span>s<span class="op">,</span>b1<span class="op">*</span>s)</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</section>
</section>
<section id="geometry" class="level1">
<h1>Geometry</h1>
<p>With floating-point calculations, round-off can become a problem. If we bounce a ray off a sphere, how do we make sure that we don’t detect another intersection with the same sphere? One way is to make sure that every ray travels a mininum distance before bouncing off anything. We’ll call this distance <code>EPS</code>, short for <em>epsilon</em>, being the greek letter <span class="math inline">\(\epsilon\)</span>, generally denoting small quantities.</p>
<div class="named-code-block">
<p>«constants»</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> EPS<span class="op">:</span> <span class="dt">f64</span> <span class="op">=</span> <span class="dv">1e-4</span><span class="op">;</span></span></code></pre></div>
</div>
<section id="objects" class="level2">
<h2>Objects</h2>
<p>The only objects in our scene are spheres. When we do path tracing, we also need rays.</p>
<div class="named-code-block">
<p>«ray»</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Ray</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="kw">pub</span> origin<span class="op">:</span> Vec3</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> <span class="kw">pub</span> direction<span class="op">:</span> Vec3 <span class="op">}</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«sphere»</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Sphere</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="kw">pub</span> radius<span class="op">:</span> <span class="dt">f64</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> <span class="kw">pub</span> position<span class="op">:</span> Vec3</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>sphere<span class="op">-</span>members<span class="op">&gt;&gt;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
</div>
</section>
<section id="intersections" class="level2">
<h2>Intersections</h2>
<p>The <code>Shpere</code> has a method to detect intersection with a <code>Ray</code>.</p>
<div class="named-code-block">
<p>«sphere»</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Sphere <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> intersect(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> ray<span class="op">:</span> <span class="op">&amp;</span>Ray) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span>sphere<span class="op">-</span>ray<span class="op">-</span>intersect<span class="op">&gt;&gt;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>The equation for the surface of a sphere at position <span class="math inline">\(\vec{p}\)</span> and radius <span class="math inline">\(r\)</span> is,</p>
<p><span id="eq:sphere" class="eqnos"><span class="math display">\[S:\ (\vec{p} - \vec{x})^2 = r^2,\]</span><span class="eqnos-number">(1)</span></span></p>
<p>and a ray from origin <span class="math inline">\(\vec{o}\)</span> and direction <span class="math inline">\(\vec{\hat{d}}\)</span> describes the half-line,</p>
<p><span id="eq:ray" class="eqnos"><span class="math display">\[L:\ \vec{x} = \vec{o} + t\vec{\hat{d}}.\]</span><span class="eqnos-number">(2)</span></span></p>
<p>Equating these gives a quadratic equation for <span class="math inline">\(t\)</span>, taking <span class="math inline">\(\vec{q} = \vec{p} - \vec{o}\)</span>,</p>
<p><span id="eq:sphere-ray-intersect" class="eqnos"><span class="math display">\[\begin{align}
S \cap L:\ &amp;(\vec{p} - \vec{o} - t\vec{\hat{d}})^2 = r^2\\
           &amp;t^2 - 2t\vec{\hat{d}}\vec{q} + \vec{q}^2 - r^2 = 0\\
           &amp;t = \vec{\hat{d}}\vec{q} \pm \sqrt{(\vec{\hat{d}}\vec{q})^2 - \vec{q}^2 + r^2}.
\end{align}\]</span><span class="eqnos-number">(3)</span></span></p>
<p>We first compute the determinant (part under the square root),</p>
<div class="named-code-block">
<p>«sphere-ray-intersect»</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> q <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>position <span class="op">-</span> ray<span class="op">.</span>origin<span class="op">;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> b <span class="op">=</span> ray<span class="op">.</span>direction <span class="op">*</span> q<span class="op">;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> r <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>radius<span class="op">;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> det <span class="op">=</span> b<span class="op">*</span>b <span class="op">-</span> q<span class="op">*</span>q <span class="op">+</span> r<span class="op">*</span>r<span class="op">;</span></span></code></pre></div>
</div>
<p>If it is negative, there is no solution and the ray does not intersect with the sphere.</p>
<div class="named-code-block">
<p>«sphere-ray-intersect»</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> det <span class="op">&lt;</span> <span class="dv">0</span><span class="op">.</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="cn">None</span><span class="op">;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>Otherwise, it is safe to compute the square-root and return the first intersection at a distance larger than <code>EPS</code>.</p>
<div class="named-code-block">
<p>«sphere-ray-intersect»</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> rdet <span class="op">=</span> det<span class="op">.</span>sqrt()<span class="op">;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> b <span class="op">-</span> rdet <span class="op">&gt;</span> EPS <span class="op">{</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Some</span>(b <span class="op">-</span> rdet)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span> b <span class="op">+</span> rdet <span class="op">&gt;</span> EPS <span class="op">{</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Some</span>(b <span class="op">+</span> rdet)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    <span class="cn">None</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</section>
<section id="properties" class="level2">
<h2>Properties</h2>
<p>A sphere has material properties. We can choose between <em>diffuse</em>, <em>specular</em> and <em>refractive</em> type.</p>
<div class="named-code-block">
<p>«material»</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Reflection</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> Diffuse</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> Specular</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> Refractive <span class="op">}</span></span></code></pre></div>
</div>
<section id="sum-types" class="level3 alert alert-info">
<h3>Sum types</h3>
<p>Note that the Rust <code>enum</code> types are much richer than the <code>enum</code> you may be used to from C/C++. Together with <code>struct</code>, <code>enum</code> gives the corner stones of <em>algebraic data types</em>. Where a <code>struct</code> collects different members into a <em>product type</em>, an <code>enum</code> is a <em>sum type</em>, meaning that it either contains one value or the other.</p>
</section>
<div class="named-code-block">
<p>«sphere-members»</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> <span class="kw">pub</span> emission<span class="op">:</span> RGBColour</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> <span class="kw">pub</span> colour<span class="op">:</span> RGBColour</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> <span class="kw">pub</span> reflection<span class="op">:</span> Reflection</span></code></pre></div>
</div>
</section>
</section>
<section id="scene" class="level1">
<h1>Scene</h1>
<p>The scene in SmallPt is an adaptation of the Cornell box.</p>
<div class="named-code-block">
<p>«scene»</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> SPHERES<span class="op">:</span> [Sphere<span class="op">;</span><span class="dv">9</span>] <span class="op">=</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>scene<span class="op">-</span>spheres<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>The scene consists of a red ceiling,</p>
<div class="named-code-block">
<p>«scene-spheres»</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>[ Sphere <span class="op">{</span> radius<span class="op">:</span>  <span class="dv">1e5</span><span class="op">,</span>  position<span class="op">:</span> vec(<span class="dv">1e5</span><span class="op">+</span><span class="dv">1</span><span class="op">.,</span>   <span class="dv">40.8</span><span class="op">,</span> <span class="dv">81.6</span>)<span class="op">,</span> emission<span class="op">:</span> BLACK</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> colour<span class="op">:</span> rgb(<span class="dv">0.75</span><span class="op">,</span> <span class="dv">0.25</span><span class="op">,</span> <span class="dv">0.25</span>)<span class="op">,</span> reflection<span class="op">:</span> <span class="pp">Reflection::</span>Diffuse <span class="op">}</span></span></code></pre></div>
</div>
<p>four grey walls, one of which is black to emulate photons escaping,</p>
<div class="named-code-block">
<p>«scene-spheres»</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> Sphere <span class="op">{</span> radius<span class="op">:</span>  <span class="dv">1e5</span><span class="op">,</span>  position<span class="op">:</span> vec(<span class="dv">50</span><span class="op">.,</span> <span class="dv">40.8</span><span class="op">,</span> <span class="dv">1e5</span>)<span class="op">,</span>       emission<span class="op">:</span> BLACK</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> colour<span class="op">:</span> rgb(<span class="dv">0.75</span><span class="op">,</span> <span class="dv">0.75</span><span class="op">,</span> <span class="dv">0.75</span>)<span class="op">,</span> reflection<span class="op">:</span> <span class="pp">Reflection::</span>Diffuse <span class="op">}</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> Sphere <span class="op">{</span> radius<span class="op">:</span>  <span class="dv">1e5</span><span class="op">,</span>  position<span class="op">:</span> vec(<span class="dv">50</span><span class="op">.,</span> <span class="dv">40.8</span><span class="op">,</span> <span class="op">-</span><span class="dv">1e5</span><span class="op">+</span><span class="dv">170</span><span class="op">.</span>)<span class="op">,</span>  emission<span class="op">:</span> BLACK</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> colour<span class="op">:</span> BLACK<span class="op">,</span>                 reflection<span class="op">:</span> <span class="pp">Reflection::</span>Diffuse <span class="op">}</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> Sphere <span class="op">{</span> radius<span class="op">:</span>  <span class="dv">1e5</span><span class="op">,</span>  position<span class="op">:</span> vec(<span class="dv">50</span><span class="op">.,</span> <span class="dv">1e5</span><span class="op">,</span> <span class="dv">81.6</span>)<span class="op">,</span>       emission<span class="op">:</span> BLACK</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> colour<span class="op">:</span> rgb(<span class="dv">0.75</span><span class="op">,</span> <span class="dv">0.75</span><span class="op">,</span> <span class="dv">0.75</span>)<span class="op">,</span> reflection<span class="op">:</span> <span class="pp">Reflection::</span>Diffuse <span class="op">}</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> Sphere <span class="op">{</span> radius<span class="op">:</span>  <span class="dv">1e5</span><span class="op">,</span>  position<span class="op">:</span> vec(<span class="dv">50</span><span class="op">.,</span> <span class="op">-</span><span class="dv">1e5</span><span class="op">+</span><span class="dv">81.6</span><span class="op">,</span> <span class="dv">81.6</span>)<span class="op">,</span> emission<span class="op">:</span> BLACK</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> colour<span class="op">:</span> rgb(<span class="dv">0.75</span><span class="op">,</span> <span class="dv">0.75</span><span class="op">,</span> <span class="dv">0.75</span>)<span class="op">,</span> reflection<span class="op">:</span> <span class="pp">Reflection::</span>Diffuse <span class="op">}</span></span></code></pre></div>
</div>
<p>a blue floor,</p>
<div class="named-code-block">
<p>«scene-spheres»</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> Sphere <span class="op">{</span> radius<span class="op">:</span>  <span class="dv">1e5</span><span class="op">,</span>  position<span class="op">:</span> vec(<span class="op">-</span><span class="dv">1e5</span><span class="op">+</span><span class="dv">99</span><span class="op">.,</span> <span class="dv">40.8</span><span class="op">,</span> <span class="dv">81.6</span>)<span class="op">,</span> emission<span class="op">:</span> BLACK</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> colour<span class="op">:</span> rgb(<span class="dv">0.25</span><span class="op">,</span> <span class="dv">0.25</span><span class="op">,</span> <span class="dv">0.75</span>)<span class="op">,</span> reflection<span class="op">:</span> <span class="pp">Reflection::</span>Diffuse <span class="op">}</span></span></code></pre></div>
</div>
<p>a glass and a metal sphere,</p>
<div class="named-code-block">
<p>«scene-spheres»</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> Sphere <span class="op">{</span> radius<span class="op">:</span> <span class="dv">16.5</span><span class="op">,</span>  position<span class="op">:</span> vec(<span class="dv">27</span><span class="op">.,</span> <span class="dv">16.5</span><span class="op">,</span> <span class="dv">47</span><span class="op">.</span>)<span class="op">,</span> emission<span class="op">:</span> BLACK</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> colour<span class="op">:</span> rgb(<span class="dv">0.999</span><span class="op">,</span> <span class="dv">0.999</span><span class="op">,</span> <span class="dv">0.999</span>)<span class="op">,</span> reflection<span class="op">:</span> <span class="pp">Reflection::</span>Specular <span class="op">}</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> Sphere <span class="op">{</span> radius<span class="op">:</span> <span class="dv">16.5</span><span class="op">,</span>  position<span class="op">:</span> vec(<span class="dv">73</span><span class="op">.,</span> <span class="dv">16.5</span><span class="op">,</span> <span class="dv">78</span><span class="op">.</span>)<span class="op">,</span> emission<span class="op">:</span> BLACK</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> colour<span class="op">:</span> rgb(<span class="dv">0.999</span><span class="op">,</span> <span class="dv">0.999</span><span class="op">,</span> <span class="dv">0.999</span>)<span class="op">,</span> reflection<span class="op">:</span> <span class="pp">Reflection::</span>Refractive <span class="op">}</span></span></code></pre></div>
</div>
<p>and a plafonniere</p>
<div class="named-code-block">
<p>«scene-spheres»</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> Sphere <span class="op">{</span> radius<span class="op">:</span>  <span class="dv">600</span><span class="op">.,</span>  position<span class="op">:</span> vec(<span class="dv">50</span><span class="op">.,</span> <span class="dv">681.6</span><span class="op">-</span><span class="dv">0.27</span><span class="op">,</span> <span class="dv">81.6</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> emission<span class="op">:</span> rgb(<span class="dv">12.0</span><span class="op">,</span> <span class="dv">12.0</span><span class="op">,</span> <span class="dv">12.0</span>)<span class="op">,</span> colour<span class="op">:</span> BLACK</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> reflection<span class="op">:</span> <span class="pp">Reflection::</span>Diffuse <span class="op">}</span> ]<span class="op">;</span></span></code></pre></div>
</div>
<p>Given this scene, we can define the function <code>intersect</code> which computes the first intersection of a ray with any of the objects in the scene. If the ray intersects, a tuple is returned giving the distance and reference to the obstructing object.</p>
<div class="named-code-block">
<p>«scene»</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> intersect(ray<span class="op">:</span> <span class="op">&amp;</span>Ray) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>(<span class="dt">f64</span><span class="op">,</span> <span class="op">&amp;</span><span class="ot">&#39;static</span> Sphere)<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> result <span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span>(<span class="dt">f64</span><span class="op">,</span> <span class="op">&amp;</span>Sphere)<span class="op">&gt;</span> <span class="op">=</span> <span class="cn">None</span><span class="op">;</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> s <span class="kw">in</span> <span class="op">&amp;</span>SPHERES <span class="op">{</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(d) <span class="op">=</span> s<span class="op">.</span>intersect(ray) <span class="op">{</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> result<span class="op">.</span>is_none() <span class="op">||</span> result<span class="op">.</span>unwrap()<span class="op">.</span><span class="dv">0</span> <span class="op">&gt;</span> d <span class="op">{</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>                result <span class="op">=</span> <span class="cn">Some</span>((d<span class="op">,</span> s))<span class="op">;</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    result</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>It feel like we’ve done a lot of work here, but we’ve only arrived at line 48 of SmallPt.</p>
</section>
<section id="path-tracing" class="level1">
<h1>Path tracing</h1>
<p>This is where all the physics happens. We need to generate random numbers.</p>
<div class="named-code-block">
<p>«imports»</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="kw">crate</span> rand<span class="op">;</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">rand::</span>Rng<span class="op">;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«constants»</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::</span><span class="dt">f64</span><span class="pp">::consts::</span>PI<span class="op">;</span></span></code></pre></div>
</div>
<p>The <code>radiance</code> function computes how many photons are traveling at a certain position in space from a certain direction.</p>
<section id="recursion" class="level3 alert">
<h3>Recursion</h3>
<p>One major change with respect to the original SmallPT is the recursion. SmallPT uses true recursion to compute the radiance of a ray. In Rust, this has led to some instances where a stack overflow was triggered. We may use a stack based implementation to prevent this from happening, but this has proven to be quite a bit slower. I ended up using a <code>loop</code>, modifying the traced path in place. Only in the case of partial reflection do we recursively call the <code>radiance</code> function.</p>
<p>The result of each recursive radiance computation goes into an affine transformation (<span class="math inline">\(ax + b\)</span>). We may compose two transformations</p>
<p><span class="math display">\[(x \to ax + b) \circ (y \to cy + d) = y \to a(cy + d) + b = y \to acy + ad + b,\]</span></p>
<p>meaning that if we express an affine transformation as a pair <span class="math inline">\((a, b)\)</span> and a second <span class="math inline">\((c, d)\)</span>, we have <span class="math inline">\((a, b) \circ (c, d) = (ac, ad + b)\)</span>. This means we have a compact way to codify the contribution of each scattered ray.</p>
</section>
<div class="named-code-block">
<p>«path-tracing»</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> radiance(ray<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Ray<span class="op">,</span> <span class="kw">mut</span> depth<span class="op">:</span> <span class="dt">u16</span>) <span class="op">-&gt;</span> RGBColour <span class="op">{</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> rng <span class="op">=</span> <span class="pp">rand::</span>thread_rng()<span class="op">;</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> colour <span class="op">=</span> WHITE<span class="op">;</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> output <span class="op">=</span> BLACK<span class="op">;</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">loop</span> <span class="op">{</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span><span class="kw">do</span><span class="op">-</span>intersect<span class="op">&gt;&gt;</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span>russian<span class="op">-</span>roulette<span class="op">-</span><span class="dv">1</span><span class="op">&gt;&gt;</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span>compute<span class="op">-</span>normal<span class="op">&gt;&gt;</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span><span class="kw">do</span><span class="op">-</span>reflect<span class="op">&gt;&gt;</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>The second argument keeps track of how deep we are tracing. It is used as a control to switch between sampling methods. One method is to reduce the brightness of the ray at every reflection off a diffuse object until we hit a light source. The second method, also known as <em>Russion Roulette</em>, is to keep the brightness of the ray constant, but only reflect with a probability given by the colour of the object. The first method will always give a nice smooth image but may take a long time wasted on very dim rays. The Russian Roulette wastes less time per sample, but produces grainy images at low sample rates. That is why SmallPt switches sampling methods if we are deeper than <span class="math inline">\(n\)</span> reflections.</p>
<p>First, we need to see if the ray intersects any object in the scene; if not, we return the colour <code>BLACK</code>.</p>
<div class="named-code-block">
<p>«do-intersect»</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> hit <span class="op">=</span> intersect(<span class="op">&amp;</span>ray)<span class="op">;</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> hit<span class="op">.</span>is_none() <span class="op">{</span> <span class="kw">return</span> output<span class="op">;</span> <span class="op">}</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (distance<span class="op">,</span> object) <span class="op">=</span> hit<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> output <span class="op">+</span> object<span class="op">.</span>emission <span class="op">*</span> colour<span class="op">;</span></span></code></pre></div>
</div>
<section id="russian-roulette-1" class="level2">
<h2>Russian Roulette 1</h2>
<p>The colour <span class="math inline">\(f\)</span> of an object reduces the radiance of a ray compared to the radiance of the reflected ray.</p>
<p><span id="eq:reflected-radiance" class="eqnos"><span class="math display">\[r = f r_{\rm refl}.\]</span><span class="eqnos-number">(4)</span></span></p>
<p>The first Russian Roulette happens at an integration depth of 5. The value <span class="math inline">\(p\)</span> is the probability of the ray being reflected. The value of <span class="math inline">\(p\)</span> can be anything between <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>, and the math would still work out, however we choose it to be the maximum value of the colour of the object. Once the ray has overcome the odds of being absorbed, we have to renormalize the colour. If <span class="math inline">\(p = 1\)</span> the colour should remain the same. In other words,</p>
<p><span id="eq:russian-roulette" class="eqnos"><span class="math display">\[r = \frac{1}{N}\sum_{\rm N} p f&#39; r_{\rm refl} = f r_{\rm refl},\]</span><span class="eqnos-number">(5)</span></span></p>
<p>meaning that <span class="math display">\[f&#39; = f / p\]</span>. If the ray got absorbed, the radiance equals the emission of the object.</p>
<div class="named-code-block">
<p>«russian-roulette-1»</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> f <span class="op">=</span> object<span class="op">.</span>colour<span class="op">;</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> p <span class="op">=</span> f<span class="op">.</span>max()<span class="op">;</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>depth <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> depth <span class="op">&gt;</span> <span class="dv">5</span> <span class="op">{</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> rng<span class="op">.</span><span class="pp">gen::</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span>() <span class="op">&lt;</span> p <span class="op">{</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>        f <span class="op">=</span> f <span class="op">*</span> (<span class="dv">1</span><span class="op">.</span> <span class="op">/</span> p)<span class="op">;</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> output<span class="op">;</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// current = stack.pop();</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// continue;</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</section>
<section id="normals" class="level2">
<h2>Normals</h2>
<p>Now that we know that we hit an object, we need to compute the normal vector. Let <span class="math inline">\(x\)</span> be the position where the ray hits the object, and <span class="math inline">\(\vec{n}\)</span> be the normal vector (outward pointing) of the object.</p>
<div class="named-code-block">
<p>«compute-normal»</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="op">=</span> ray<span class="op">.</span>origin <span class="op">+</span> ray<span class="op">.</span>direction <span class="op">*</span> distance<span class="op">;</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> n <span class="op">=</span> (x <span class="op">-</span> object<span class="op">.</span>position)<span class="op">.</span>normalize()<span class="op">;</span></span></code></pre></div>
</div>
<p>It could be that we’re inside the object. In that case, the normal of reflection is opposite the normal of the object.</p>
<div class="named-code-block">
<p>«compute-normal»</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> n_refl <span class="op">=</span> <span class="kw">if</span> n <span class="op">*</span> ray<span class="op">.</span>direction <span class="op">&lt;</span> <span class="dv">0</span><span class="op">.</span> <span class="op">{</span> n <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> <span class="op">-</span>n <span class="op">};</span></span></code></pre></div>
</div>
</section>
<section id="reflection" class="level2">
<h2>Reflection</h2>
<p>We’re at the point that we need to compute how much light is reflected. Of course, this depends on the type of material that the object is made of. SmallPt has three material types, <em>diffuse</em>, <em>specular</em>, and <em>refractive</em>, that each have their own physics.</p>
<div class="named-code-block">
<p>«do-reflect»</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> object<span class="op">.</span>reflection <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">Reflection::</span>Diffuse <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span>diffuse<span class="op">-</span>reflection<span class="op">&gt;&gt;</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">Reflection::</span>Specular <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span>specular<span class="op">-</span>reflection<span class="op">&gt;&gt;</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">Reflection::</span>Refractive <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span>refractive<span class="op">-</span>reflection<span class="op">&gt;&gt;</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
</div>
<section id="diffuse-reflection" class="level3">
<h3>Diffuse reflection</h3>
<p>There are many types of diffuse reflection. You could imagine a surface where rays have equal probability of reflecting to any direction. This would mean sampling vectors on a hemisphere. We have a uniform probability over longitude:</p>
<div class="named-code-block">
<p>«diffuse-reflection»</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> phi <span class="op">=</span> <span class="dv">2</span><span class="op">.*</span>PI <span class="op">*</span> rng<span class="op">.</span><span class="pp">gen::</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span>()<span class="op">;</span></span></code></pre></div>
</div>
<p>Taking <span class="math inline">\(\theta\)</span> to be the angle of incidence to the normal of the surface, we have a <span class="math inline">\(p(\theta) \sim \sin \theta\)</span> probability over latitude. The inverse CDF sampling method then gives than <span class="math inline">\(\cos \theta\)</span> has a uniform distribution in the interval <span class="math inline">\([0, 1]\)</span>.</p>
<p>However, there is a second effect. If you shine a uniform bundle of light on a surface at an angle, the light intensity drops with a factor <span class="math inline">\(\cos \theta\)</span>. The combination of sampling the hemisphere and the lighting is known has <em>cosine-weighted sampling</em>, and there is a trick called <em>Malley’s Method</em>. We can sample points on a uniform disc, and project those onto the hemisphere <span class="citation" data-cites="Pbr-13.6.3">(<a href="#ref-Pbr-13.6.3" role="doc-biblioref">Pharr, Jakob, and Humphreys 2017</a>)</span>.</p>
<p>On a disc we have <span class="math inline">\(p(r) \sim r\)</span>, so <span class="math inline">\(p(r^2) \sim 1\)</span>,</p>
<div class="named-code-block">
<p>«diffuse-reflection»</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> r2 <span class="op">:</span> <span class="dt">f64</span> <span class="op">=</span> rng<span class="op">.</span>gen()<span class="op">;</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> r <span class="op">=</span> r2<span class="op">.</span>sqrt()<span class="op">;</span></span></code></pre></div>
</div>
<p>We need a set of orthogonal axes in the plane of reflection. We pick a vector to start with, and compute the outer product with the normal to give one vector <span class="math inline">\(\vec{u}\)</span> orthogonal to <span class="math inline">\(\vec{n}\)</span>. To prevent numberloss, the first vector should not be too close to the normal. The second vector <span class="math inline">\(\vec{v}\)</span> is found by taking another outer product of <span class="math inline">\(\vec{u} \times \vec{n}\)</span>.</p>
<div class="named-code-block">
<p>«diffuse-reflection»</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ncl <span class="op">=</span> <span class="kw">if</span> n_refl<span class="op">.</span>x<span class="op">.</span>abs() <span class="op">&gt;</span> <span class="dv">0.1</span> <span class="op">{</span> vec(<span class="dv">0</span><span class="op">.,</span> <span class="dv">1</span><span class="op">.,</span> <span class="dv">0</span><span class="op">.</span>) <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> vec(<span class="dv">1</span><span class="op">.,</span> <span class="dv">0</span><span class="op">.,</span> <span class="dv">0</span><span class="op">.</span>) <span class="op">};</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> u <span class="op">=</span> (ncl <span class="op">%</span> n_refl)<span class="op">.</span>normalize()<span class="op">;</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> v <span class="op">=</span> n_refl <span class="op">%</span> u<span class="op">;</span></span></code></pre></div>
</div>
<p>The direction of the reflected ray is now known.</p>
<div class="named-code-block">
<p>«diffuse-reflection»</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> d <span class="op">=</span> (u<span class="op">*</span>phi<span class="op">.</span>cos()<span class="op">*</span>r <span class="op">+</span> v<span class="op">*</span>phi<span class="op">.</span>sin()<span class="op">*</span>r <span class="op">+</span> n_refl<span class="op">*</span>(<span class="dv">1</span><span class="op">.-</span>r2)<span class="op">.</span>sqrt())<span class="op">.</span>normalize()<span class="op">;</span></span></code></pre></div>
</div>
<p>To compute the radiance, we need to know the radiance from the reflected ray.</p>
<div class="named-code-block">
<p>«diffuse-reflection»</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>ray <span class="op">=</span> Ray <span class="op">{</span>origin<span class="op">:</span> x<span class="op">,</span> direction<span class="op">:</span> d<span class="op">};</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>colour <span class="op">=</span> f <span class="op">*</span> colour<span class="op">;</span></span></code></pre></div>
</div>
</section>
<section id="specular-reflection" class="level3">
<h3>Specular reflection</h3>
<p>Specular reflection means we have to mirror the incident ray with respect to the normal. This means that only the <span class="math inline">\(\vec{n}\)</span> component of the direction flips,</p>
<p><span class="math display">\[\vec{\hat{d}}&#39; = \vec{\hat{d}} - 2 \vec{\hat{n}} (\vec{\hat{n}} \cdot \vec{\hat{d}})\]</span>.</p>
<div class="named-code-block">
<p>«specular-reflection»</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> d <span class="op">=</span> ray<span class="op">.</span>direction <span class="op">-</span> n <span class="op">*</span> <span class="dv">2</span><span class="op">.*</span>(n<span class="op">*</span>ray<span class="op">.</span>direction)<span class="op">;</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>ray <span class="op">=</span> Ray <span class="op">{</span>origin<span class="op">:</span> x<span class="op">,</span> direction<span class="op">:</span> d<span class="op">};</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>colour <span class="op">=</span> f <span class="op">*</span> colour<span class="op">;</span></span></code></pre></div>
</div>
</section>
<section id="refraction" class="level3">
<h3>Refraction</h3>
<p>Now some real optics! Discarding polarisation, there are several ways a photon may go at the boundary between two transparent media: <em>total internal reflection</em>, <em>refraction</em>, or <em>partial reflection</em>.</p>
<p>There is always a reflective component,</p>
<div class="named-code-block">
<p>«refractive-reflection»</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> d <span class="op">=</span> ray<span class="op">.</span>direction <span class="op">-</span> n <span class="op">*</span> <span class="dv">2</span><span class="op">.*</span>(n<span class="op">*</span>ray<span class="op">.</span>direction)<span class="op">;</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> reflected_ray <span class="op">=</span> Ray <span class="op">{</span> origin<span class="op">:</span> x<span class="op">,</span> direction<span class="op">:</span> d <span class="op">};</span></span></code></pre></div>
</div>
<p>We need to know if we’re moving into or out of the object.</p>
<div class="named-code-block">
<p>«refractive-reflection»</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> into <span class="op">=</span> n <span class="op">*</span> n_refl <span class="op">&gt;</span> <span class="dv">0</span><span class="op">.;</span></span></code></pre></div>
</div>
</section>
<section id="refractive-index" class="level3">
<h3>Refractive index</h3>
<p>The refractive index of glass can vary, but <span class="math inline">\(n = 1.5\)</span> seems reasonable.</p>
<div class="named-code-block">
<p>«constants»</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> N_GLASS<span class="op">:</span> <span class="dt">f64</span> <span class="op">=</span> <span class="dv">1.5</span><span class="op">;</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> N_AIR<span class="op">:</span> <span class="dt">f64</span> <span class="op">=</span> <span class="dv">1.0</span><span class="op">;</span></span></code></pre></div>
</div>
<p>Depending on whether we’re entering or leaving the glass object, the effective index of refraction is <span class="math inline">\(n_{\rm air} / n_{\rm glass}\)</span> or <span class="math inline">\(n_{\rm glass} / n_{\rm air}\)</span>.</p>
<div class="named-code-block">
<p>«refractive-reflection»</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> n_eff <span class="op">=</span> <span class="kw">if</span> into <span class="op">{</span> N_AIR <span class="op">/</span> N_GLASS <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> N_GLASS <span class="op">/</span> N_AIR <span class="op">};</span></span></code></pre></div>
</div>
</section>
<section id="total-internal-reflection" class="level3">
<h3>Total internal reflection</h3>
<p>Total internal reflection happens if the angle of incidence is larger than some critical angle <span class="math inline">\(\theta_c\)</span>, given by</p>
<p><span id="eq:tir-critical-angle" class="eqnos"><span class="math display">\[\theta_c = \arcsin \frac{n_{\rm outside}}{n_{\rm inside}}.\]</span><span class="eqnos-number">(6)</span></span></p>
<p>We can easily compute <span class="math inline">\(\mu = \cos \theta\)</span> using the inner product, so with a little algebra, total-internal-reflection happens if,</p>
<p><span class="math display">\[\begin{align}
\sin \theta &amp;&gt; {n_o \over n_i}\\
\sqrt{1 - \cos^2 \theta} &amp;&gt; {n_o \over n_i}\\
1 - \mu^2 &amp;&gt; \left({n_o \over n_i}\right)^2\\
n_{\rm eff}^2 \left(1 - \mu^2\right) &amp;&gt; 1
\end{align}\]</span></p>
<div class="named-code-block">
<p>«refractive-reflection»</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mu <span class="op">=</span> ray<span class="op">.</span>direction <span class="op">*</span> n_refl<span class="op">;</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cos2t <span class="op">=</span> <span class="dv">1</span><span class="op">.</span> <span class="op">-</span> n_eff<span class="op">*</span>n_eff<span class="op">*</span>(<span class="dv">1</span><span class="op">.</span> <span class="op">-</span> mu<span class="op">*</span>mu)<span class="op">;</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> cos2t <span class="op">&lt;</span> <span class="dv">0</span><span class="op">.</span> <span class="op">{</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>total<span class="op">-</span>internal<span class="op">-</span>reflection<span class="op">&gt;&gt;</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>partial<span class="op">-</span>reflection<span class="op">&gt;&gt;</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>In that case, we recurse with the reflected ray.</p>
<div class="named-code-block">
<p>«total-internal-reflection»</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>ray <span class="op">=</span> reflected_ray<span class="op">;</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>colour <span class="op">=</span> f <span class="op">*</span> colour<span class="op">;</span></span></code></pre></div>
</div>
</section>
<section id="partial-reflection" class="level3">
<h3>Partial reflection</h3>
<p>In the case of partial reflection, we need to compute also the angle of the refracted ray. We have Snell’s law,</p>
<p><span id="eq:snellius" class="eqnos"><span class="math display">\[{\sin \theta_i \over \sin \theta_o} = {n_o \over n_i} = {1 \over n_{\rm eff}}.\]</span><span class="eqnos-number">(7)</span></span></p>
<p>We can decompose the incident ray direction into a normal component <span class="math inline">\(d_n\)</span> and a transverse component <span class="math inline">\(d_t\)</span>. Then <span class="math inline">\(|d_t| = \sin \theta_i\)</span>, and <span class="math inline">\(|d_n| = \vec{d} \cdot \vec{n} = \cos \theta_i\)</span>. Similarly we can decompose the outgoing ray direction <span class="math inline">\(\vec{d}&#39;\)</span>,</p>
<p><span class="math display">\[\begin{align}
d_t&#39; &amp;= n_{\rm eff} (\vec{d} - \mu \vec{n})\\
d_n&#39; &amp;= \sqrt{1 - n_{\rm eff}^2 |d_t|^2} \vec{n},
\end{align}\]</span></p>
<p>where <span class="math inline">\(|d_t|^2 = 1 - \mu^2\)</span>. That is convenient, because it turns out we have already computed <span class="math inline">\(|d_n&#39;|\)</span>, it is the square root of <code>cos2t</code>. Now, we also see where the total internal reflection comes from; there is no solution to Snell’s law for those angles.</p>
<div class="named-code-block">
<p>«partial-reflection»</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tdir <span class="op">=</span> (ray<span class="op">.</span>direction <span class="op">*</span> n_eff <span class="op">-</span> n_refl <span class="op">*</span> (mu<span class="op">*</span>n_eff <span class="op">+</span> cos2t<span class="op">.</span>sqrt()))<span class="op">.</span>normalize()<span class="op">;</span></span></code></pre></div>
</div>
<p>Next, we need to compute the fraction of light that is reflected. The Fresnel equations describe this process, but they are very complicated and also deal with polarisation. We use Schlick’s approximation instead <span class="citation" data-cites="Schlick1994">(<a href="#ref-Schlick1994" role="doc-biblioref">Schlick 1994</a>)</span>,</p>
<p><span class="math display">\[R(\theta) = R_0 + (1 - R_0) (1 - \mu)^5,\]</span></p>
<p>where</p>
<p><span class="math display">\[R_0 = \left(\frac{n_i - n_o}{n_i + n_o}\right)^2.\]</span></p>
<div class="named-code-block">
<p>«constants»</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> R0<span class="op">:</span> <span class="dt">f64</span> <span class="op">=</span>  (N_GLASS <span class="op">-</span> N_AIR) <span class="op">*</span> (N_GLASS <span class="op">-</span> N_AIR)</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>              <span class="op">/</span> ((N_GLASS <span class="op">+</span> N_AIR) <span class="op">*</span> (N_GLASS <span class="op">+</span> N_AIR))<span class="op">;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«partial-reflection»</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c <span class="op">=</span> <span class="dv">1</span><span class="op">.</span> <span class="op">-</span> (<span class="kw">if</span> into <span class="op">{</span> <span class="op">-</span>mu <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span>tdir <span class="op">*</span> n<span class="op">}</span>)<span class="op">;</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> re <span class="op">=</span> R0 <span class="op">+</span> (<span class="dv">1</span><span class="op">.</span> <span class="op">-</span> R0) <span class="op">*</span> c<span class="op">.</span>powf(<span class="dv">5.0</span>)<span class="op">;</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tr <span class="op">=</span> <span class="dv">1</span><span class="op">.</span> <span class="op">-</span> re<span class="op">;</span></span></code></pre></div>
</div>
</section>
<section id="russian-roulette-2" class="level3">
<h3>Russian Roulette 2</h3>
<div class="named-code-block">
<p>«partial-reflection»</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> p <span class="op">=</span> <span class="dv">0.25</span> <span class="op">+</span> <span class="dv">0.5</span><span class="op">*</span>re<span class="op">;</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> rp <span class="op">=</span> re<span class="op">/</span>p<span class="op">;</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tp <span class="op">=</span> tr<span class="op">/</span>(<span class="dv">1</span><span class="op">.-</span>p)<span class="op">;</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> depth <span class="op">&gt;</span> <span class="dv">2</span> <span class="op">{</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> rng<span class="op">.</span><span class="pp">gen::</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span>() <span class="op">&lt;</span> p <span class="op">{</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>ray <span class="op">=</span> reflected_ray<span class="op">;</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>        colour <span class="op">=</span> f <span class="op">*</span> colour <span class="op">*</span> rp<span class="op">;</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>ray <span class="op">=</span> Ray <span class="op">{</span> origin<span class="op">:</span> x<span class="op">,</span> direction<span class="op">:</span> tdir <span class="op">};</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>        colour <span class="op">=</span> f <span class="op">*</span> colour <span class="op">*</span> tp<span class="op">;</span></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r <span class="op">=</span> radiance(<span class="op">&amp;</span><span class="kw">mut</span> Ray <span class="op">{</span>origin<span class="op">:</span> x<span class="op">,</span> direction<span class="op">:</span> tdir<span class="op">},</span> depth)<span class="op">;</span></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> output <span class="op">+</span> r <span class="op">*</span> f <span class="op">*</span> colour <span class="op">*</span> tr<span class="op">;</span></span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>ray <span class="op">=</span> reflected_ray<span class="op">;</span></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>    colour <span class="op">=</span> f <span class="op">*</span> colour <span class="op">*</span> re<span class="op">;</span></span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</section>
</section>
</section>
<section id="image" class="level1">
<h1>Image</h1>
<div class="named-code-block">
<p>«image»</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Image</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> width<span class="op">:</span> <span class="dt">usize</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> height<span class="op">:</span> <span class="dt">usize</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> <span class="kw">pub</span> data<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>RGBColour<span class="op">&gt;</span> <span class="op">}</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Image <span class="op">{</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> new(width<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> height<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> Image <span class="op">{</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>        Image <span class="op">{</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>            width<span class="op">:</span> width<span class="op">,</span> height<span class="op">:</span> height<span class="op">,</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>            data<span class="op">:</span> <span class="pp">vec!</span>[BLACK<span class="op">;</span> width<span class="op">*</span>height]</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> for_each<span class="op">&lt;</span>F<span class="op">&gt;</span>(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> f<span class="op">:</span> F)</span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span> F<span class="op">:</span> <span class="bu">Send</span> <span class="op">+</span> <span class="bu">Sync</span> <span class="op">+</span> <span class="bu">Fn</span>(<span class="dt">usize</span><span class="op">,</span> <span class="dt">usize</span><span class="op">,</span> <span class="op">&amp;</span><span class="kw">mut</span> RGBColour)</span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">indicatif::</span>ParallelProgressIterator<span class="op">;</span></span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// use rayon::iter::{ParallelIterator, IntoParallelRefIterator};</span></span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> w <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>width<span class="op">;</span></span>
<span id="cb62-21"><a href="#cb62-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> size <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>size() <span class="kw">as</span> <span class="dt">u64</span><span class="op">;</span></span>
<span id="cb62-22"><a href="#cb62-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>data</span>
<span id="cb62-23"><a href="#cb62-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>par_iter_mut()<span class="op">.</span>progress_count(size)</span>
<span id="cb62-24"><a href="#cb62-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>enumerate()</span>
<span id="cb62-25"><a href="#cb62-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>for_each(<span class="op">|</span>(i<span class="op">,</span> c)<span class="op">|</span> <span class="op">{</span></span>
<span id="cb62-26"><a href="#cb62-26" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> x <span class="op">=</span> i <span class="op">%</span> w<span class="op">;</span></span>
<span id="cb62-27"><a href="#cb62-27" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> y <span class="op">=</span> i <span class="op">/</span> w<span class="op">;</span></span>
<span id="cb62-28"><a href="#cb62-28" aria-hidden="true" tabindex="-1"></a>                f(x<span class="op">,</span> y<span class="op">,</span> c)<span class="op">;</span></span>
<span id="cb62-29"><a href="#cb62-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb62-30"><a href="#cb62-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb62-31"><a href="#cb62-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-32"><a href="#cb62-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> size(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">usize</span> <span class="op">{</span> <span class="kw">self</span><span class="op">.</span>width <span class="op">*</span> <span class="kw">self</span><span class="op">.</span>height <span class="op">}</span></span>
<span id="cb62-33"><a href="#cb62-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-34"><a href="#cb62-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>print<span class="op">-</span>ppm<span class="op">&gt;&gt;</span></span>
<span id="cb62-35"><a href="#cb62-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<section id="writing-to-ppm" class="level2">
<h2>Writing to PPM</h2>
<p>To write output efficiently, we need a <code>BufWriter</code> instance.</p>
<div class="named-code-block">
<p>«print-ppm»</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> print_ppm(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> path<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::fs::</span>File<span class="op">;</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::io::</span><span class="bu">Write</span><span class="op">;</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> file <span class="op">=</span> <span class="pp">File::</span>create(path)<span class="op">?;</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> out <span class="op">=</span> <span class="pp">std::io::BufWriter::</span>new(file)<span class="op">;</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">write!</span>(<span class="op">&amp;</span><span class="kw">mut</span> out<span class="op">,</span> <span class="st">&quot;P3</span><span class="sc">\n</span><span class="st">{} {}</span><span class="sc">\n</span><span class="st">{}</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">self</span><span class="op">.</span>width<span class="op">,</span> <span class="kw">self</span><span class="op">.</span>height<span class="op">,</span> <span class="dv">255</span>)<span class="op">?;</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> rgb <span class="kw">in</span> <span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>data <span class="op">{</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (r<span class="op">,</span> g<span class="op">,</span> b) <span class="op">=</span> rgb<span class="op">.</span>to_u24()<span class="op">;</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>        <span class="pp">write!</span>(<span class="op">&amp;</span><span class="kw">mut</span> out<span class="op">,</span> <span class="st">&quot;{} {} {} &quot;</span><span class="op">,</span> r<span class="op">,</span> g<span class="op">,</span> b)<span class="op">?;</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(())</span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</section>
</section>
<section id="main" class="level1">
<h1>Main</h1>
<section id="argument-parsing" class="level2">
<h2>Argument parsing</h2>
<div class="named-code-block">
<p>«imports»</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="kw">crate</span> argh<span class="op">;</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">argh::</span>FromArgs<span class="op">;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«constants»</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> SAMPLES<span class="op">:</span> <span class="dt">usize</span> <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> WIDTH<span class="op">:</span> <span class="dt">usize</span> <span class="op">=</span> <span class="dv">640</span><span class="op">;</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> HEIGHT<span class="op">:</span> <span class="dt">usize</span> <span class="op">=</span> <span class="dv">480</span><span class="op">;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«arghs»</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span>FromArgs<span class="at">)]</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="co">/// Renders the Cornell box as interpreted by Kevin Beason&#39;s SmallPt</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Arghs <span class="op">{</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// optional sample size (100)</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>argh<span class="at">(</span>option<span class="op">,</span> short <span class="op">=</span> <span class="ch">&#39;s&#39;</span><span class="op">,</span> <span class="kw">default</span> <span class="op">=</span> <span class="st">&quot;SAMPLES&quot;</span><span class="at">)]</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>    samples<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// optional thread count</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// the default (0) will take the systems logical cpu count</span></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>argh<span class="at">(</span>option<span class="op">,</span> short <span class="op">=</span> <span class="ch">&#39;t&#39;</span><span class="op">,</span> <span class="kw">default</span> <span class="op">=</span> <span class="st">&quot;0&quot;</span><span class="at">)]</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>    threads<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// optional stack size in MB per thread</span></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>argh<span class="at">(</span>option<span class="op">,</span> short <span class="op">=</span> <span class="ch">&#39;z&#39;</span><span class="op">,</span> <span class="kw">default</span> <span class="op">=</span> <span class="st">&quot;8&quot;</span><span class="at">)]</span></span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>    stack<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// optional image size dimensions WxH (640x480)</span></span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>argh<span class="at">(</span>option<span class="op">,</span> from_str_fn<span class="at">(</span>into_plot_dimensions<span class="at">)</span><span class="op">,</span> <span class="kw">default</span> <span class="op">=</span> <span class="st">&quot;(WIDTH, HEIGHT)&quot;</span><span class="at">)]</span></span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a>    wxh<span class="op">:</span> (<span class="dt">usize</span><span class="op">,</span> <span class="dt">usize</span>)<span class="op">,</span></span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a><span class="co">// Helper function for parsing plot dimensions from command line arguments.</span></span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> into_plot_dimensions(dim<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>(<span class="dt">usize</span><span class="op">,</span> <span class="dt">usize</span>)<span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (w<span class="op">,</span> h) <span class="op">=</span> dim</span>
<span id="cb66-25"><a href="#cb66-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>split_once(<span class="ch">&#39;x&#39;</span>)</span>
<span id="cb66-26"><a href="#cb66-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>ok_or(<span class="st">&quot;dimensions do not parse, no delimiter?&quot;</span>)<span class="op">?;</span></span>
<span id="cb66-27"><a href="#cb66-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> w <span class="op">=</span> w<span class="op">.</span><span class="pp">parse::</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;</span>()<span class="op">.</span>map_err(<span class="op">|</span>e<span class="op">|</span> e<span class="op">.</span>to_string())<span class="op">?;</span></span>
<span id="cb66-28"><a href="#cb66-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> h <span class="op">=</span> h<span class="op">.</span><span class="pp">parse::</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;</span>()<span class="op">.</span>map_err(<span class="op">|</span>e<span class="op">|</span> e<span class="op">.</span>to_string())<span class="op">?;</span></span>
<span id="cb66-29"><a href="#cb66-29" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>((w<span class="op">,</span> h))</span>
<span id="cb66-30"><a href="#cb66-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</section>
<section id="the-main-file" class="level2">
<h2>The main file</h2>
<div class="named-code-block">
<p>file:src/main.rs</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>import<span class="op">-</span>quickcheck<span class="op">&gt;&gt;</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>imports<span class="op">&gt;&gt;</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="kw">crate</span> indicatif<span class="op">;</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="kw">mod</span> vec3<span class="op">;</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">vec3::</span><span class="op">*;</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a><span class="kw">mod</span> colour<span class="op">;</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">colour::</span><span class="op">*;</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>constants<span class="op">&gt;&gt;</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>ray<span class="op">&gt;&gt;</span></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>material<span class="op">&gt;&gt;</span></span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>sphere<span class="op">&gt;&gt;</span></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>scene<span class="op">&gt;&gt;</span></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>path<span class="op">-</span>tracing<span class="op">&gt;&gt;</span></span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>image<span class="op">&gt;&gt;</span></span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>arghs<span class="op">&gt;&gt;</span></span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// use rayon::current_thread_index;</span></span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// rayon::ThreadPoolBuilder::new().num_threads(4).build_global().unwrap();</span></span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> args<span class="op">:</span> Arghs <span class="op">=</span> <span class="pp">argh::</span>from_env()<span class="op">;</span></span>
<span id="cb67-24"><a href="#cb67-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (w<span class="op">,</span> h) <span class="op">=</span> args<span class="op">.</span>wxh<span class="op">;</span></span>
<span id="cb67-25"><a href="#cb67-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> samps <span class="op">=</span> args<span class="op">.</span>samples <span class="op">/</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb67-26"><a href="#cb67-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-27"><a href="#cb67-27" aria-hidden="true" tabindex="-1"></a>    <span class="pp">rayon::ThreadPoolBuilder::</span>new()</span>
<span id="cb67-28"><a href="#cb67-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>num_threads(args<span class="op">.</span>threads)</span>
<span id="cb67-29"><a href="#cb67-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>stack_size(args<span class="op">.</span>stack <span class="op">*</span> <span class="dv">1024</span> <span class="op">*</span> <span class="dv">1024</span>)</span>
<span id="cb67-30"><a href="#cb67-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>build_global()</span>
<span id="cb67-31"><a href="#cb67-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb67-32"><a href="#cb67-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-33"><a href="#cb67-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> cam <span class="op">=</span> Ray <span class="op">{</span> origin<span class="op">:</span> vec(<span class="dv">50</span><span class="op">.,</span> <span class="dv">52</span><span class="op">.,</span> <span class="dv">295.6</span>)<span class="op">,</span> direction<span class="op">:</span> vec(<span class="dv">0.0</span><span class="op">,</span> <span class="op">-</span><span class="dv">0.045</span><span class="op">,</span> <span class="op">-</span><span class="dv">1.0</span>)<span class="op">.</span>normalize() <span class="op">};</span></span>
<span id="cb67-34"><a href="#cb67-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> cx <span class="op">=</span> vec(w <span class="kw">as</span> <span class="dt">f64</span> <span class="op">*</span> <span class="dv">0.510</span> <span class="op">/</span> h <span class="kw">as</span> <span class="dt">f64</span><span class="op">,</span> <span class="dv">0</span><span class="op">.,</span> <span class="dv">0</span><span class="op">.</span>)<span class="op">;</span></span>
<span id="cb67-35"><a href="#cb67-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> cy <span class="op">=</span> (cx <span class="op">%</span> cam<span class="op">.</span>direction)<span class="op">.</span>normalize() <span class="op">*</span> <span class="dv">0.510</span><span class="op">;</span></span>
<span id="cb67-36"><a href="#cb67-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-37"><a href="#cb67-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> img <span class="op">=</span> <span class="pp">Image::</span>new(w<span class="op">,</span> h)<span class="op">;</span></span>
<span id="cb67-38"><a href="#cb67-38" aria-hidden="true" tabindex="-1"></a>    <span class="pp">eprintln!</span>(<span class="st">&quot;Rendering ({} spp)&quot;</span><span class="op">,</span> samps<span class="op">*</span><span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb67-39"><a href="#cb67-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-40"><a href="#cb67-40" aria-hidden="true" tabindex="-1"></a>    img<span class="op">.</span>for_each(<span class="op">|</span>x<span class="op">,</span> y<span class="op">,</span> c<span class="op">|</span> <span class="op">{</span></span>
<span id="cb67-41"><a href="#cb67-41" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> rng <span class="op">=</span> <span class="pp">rand::</span>thread_rng()<span class="op">;</span></span>
<span id="cb67-42"><a href="#cb67-42" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> sy <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">2</span> <span class="op">{</span></span>
<span id="cb67-43"><a href="#cb67-43" aria-hidden="true" tabindex="-1"></a>            <span class="kw">for</span> sx <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">2</span> <span class="op">{</span></span>
<span id="cb67-44"><a href="#cb67-44" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> <span class="kw">mut</span> r <span class="op">=</span> BLACK<span class="op">.</span>clone()<span class="op">;</span></span>
<span id="cb67-45"><a href="#cb67-45" aria-hidden="true" tabindex="-1"></a>                <span class="kw">for</span> _ <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span>samps <span class="op">{</span></span>
<span id="cb67-46"><a href="#cb67-46" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> r1 <span class="op">=</span> <span class="dv">2</span><span class="op">.</span> <span class="op">*</span> rng<span class="op">.</span><span class="pp">gen::</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span>()<span class="op">;</span></span>
<span id="cb67-47"><a href="#cb67-47" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> dx <span class="op">=</span> <span class="kw">if</span> r1 <span class="op">&lt;</span> <span class="dv">1</span><span class="op">.</span> <span class="op">{</span> r1<span class="op">.</span>sqrt() <span class="op">-</span> <span class="dv">1</span><span class="op">.</span> <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> <span class="dv">1</span><span class="op">.</span> <span class="op">-</span> (<span class="dv">2</span><span class="op">.</span> <span class="op">-</span> r1)<span class="op">.</span>sqrt() <span class="op">};</span></span>
<span id="cb67-48"><a href="#cb67-48" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> r2 <span class="op">=</span> <span class="dv">2</span><span class="op">.</span> <span class="op">*</span> rng<span class="op">.</span><span class="pp">gen::</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span>()<span class="op">;</span></span>
<span id="cb67-49"><a href="#cb67-49" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> dy <span class="op">=</span> <span class="kw">if</span> r2 <span class="op">&lt;</span> <span class="dv">1</span><span class="op">.</span> <span class="op">{</span> r2<span class="op">.</span>sqrt() <span class="op">-</span> <span class="dv">1</span><span class="op">.</span> <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> <span class="dv">1</span><span class="op">.</span> <span class="op">-</span> (<span class="dv">2</span><span class="op">.</span> <span class="op">-</span> r2)<span class="op">.</span>sqrt() <span class="op">};</span></span>
<span id="cb67-50"><a href="#cb67-50" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> d <span class="op">=</span> cx<span class="op">*</span>( ( (sx <span class="kw">as</span> <span class="dt">f64</span> <span class="op">+</span> <span class="dv">0.5</span> <span class="op">+</span> dx) <span class="op">/</span> <span class="dv">2</span><span class="op">.</span> <span class="op">+</span> x <span class="kw">as</span> <span class="dt">f64</span>) <span class="op">/</span> w <span class="kw">as</span> <span class="dt">f64</span> <span class="op">-</span> <span class="dv">0.5</span> )</span>
<span id="cb67-51"><a href="#cb67-51" aria-hidden="true" tabindex="-1"></a>                          <span class="op">+</span> cy<span class="op">*</span>( ( (sy <span class="kw">as</span> <span class="dt">f64</span> <span class="op">+</span> <span class="dv">0.5</span> <span class="op">+</span> dy) <span class="op">/</span> <span class="dv">2</span><span class="op">.</span> <span class="op">+</span> (h <span class="op">-</span> y <span class="op">-</span> <span class="dv">1</span>) <span class="kw">as</span> <span class="dt">f64</span>) <span class="op">/</span> h <span class="kw">as</span> <span class="dt">f64</span> <span class="op">-</span> <span class="dv">0.5</span> )</span>
<span id="cb67-52"><a href="#cb67-52" aria-hidden="true" tabindex="-1"></a>                          <span class="op">+</span> cam<span class="op">.</span>direction<span class="op">;</span></span>
<span id="cb67-53"><a href="#cb67-53" aria-hidden="true" tabindex="-1"></a>                    r <span class="op">=</span> r <span class="op">+</span> radiance(<span class="op">&amp;</span><span class="kw">mut</span> Ray <span class="op">{</span>origin<span class="op">:</span> cam<span class="op">.</span>origin <span class="op">+</span> d<span class="op">*</span><span class="dv">140</span><span class="op">.,</span> direction<span class="op">:</span> d<span class="op">.</span>normalize()<span class="op">},</span> <span class="dv">0</span>) <span class="op">*</span> (<span class="dv">1</span><span class="op">./</span>samps <span class="kw">as</span> <span class="dt">f64</span>)<span class="op">;</span></span>
<span id="cb67-54"><a href="#cb67-54" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb67-55"><a href="#cb67-55" aria-hidden="true" tabindex="-1"></a>                <span class="op">*</span>c <span class="op">=</span> <span class="op">*</span>c <span class="op">+</span> r<span class="op">.</span>clamp() <span class="op">*</span> <span class="dv">0.25</span><span class="op">;</span></span>
<span id="cb67-56"><a href="#cb67-56" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb67-57"><a href="#cb67-57" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb67-58"><a href="#cb67-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb67-59"><a href="#cb67-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-60"><a href="#cb67-60" aria-hidden="true" tabindex="-1"></a>    <span class="pp">eprintln!</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">Writing image.&quot;</span>)<span class="op">;</span></span>
<span id="cb67-61"><a href="#cb67-61" aria-hidden="true" tabindex="-1"></a>    img<span class="op">.</span>print_ppm(<span class="st">&quot;image_rust.ppm&quot;</span>)</span>
<span id="cb67-62"><a href="#cb67-62" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</section>
</section>
<section id="bibliography" class="level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-Pbr-13.6.3" class="csl-entry" role="doc-biblioentry">
Pharr, Matt, Wenzel Jakob, and Greg Humphreys. 2017. <span>“Cosine-Weighted Hemisphere Sampling.”</span> In <em>Physically Based Rendering</em>, Third Edition. Morgan Kaufmann. <a href="http://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/2D_Sampling_with_Multidimensional_Transformations.html#Cosine-WeightedHemisphereSampling">http://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/2D_Sampling_with_Multidimensional_Transformations.html#Cosine-WeightedHemisphereSampling</a>.
</div>
<div id="ref-Schlick1994" class="csl-entry" role="doc-biblioentry">
Schlick, Christophe. 1994. <span>“An Inexpensive BRDF Model for Physically-Based Rendering.”</span> <em>Computer Graphics Forum</em> 13 (3): 233–46. <a href="https://doi.org/10.1111/1467-8659.1330233">https://doi.org/10.1111/1467-8659.1330233</a>.
</div>
</div>
</section>
        </div>
         <div class="col-3 col-s-3 menu" id="menu-container">
                <div id="menu"><nav id="TOC" role="doc-toc">
                                <ul>
                                <li><a href="#literatept">LiteratePT</a>
                                <ul>
                                <li><a href="#todo">TODO</a></li>
                                <li><a href="#getting-started-with-rust">Getting started with Rust</a></li>
                                <li><a href="#outline">Outline</a></li>
                                </ul></li>
                                <li><a href="#vectors">Vectors</a>
                                <ul>
                                <li><a href="#operators">Operators</a></li>
                                <li><a href="#tests">Tests</a></li>
                                </ul></li>
                                <li><a href="#colours">Colours</a>
                                <ul>
                                <li><a href="#constants">Constants</a></li>
                                <li><a href="#operators-1">Operators</a></li>
                                </ul></li>
                                <li><a href="#geometry">Geometry</a>
                                <ul>
                                <li><a href="#objects">Objects</a></li>
                                <li><a href="#intersections">Intersections</a></li>
                                <li><a href="#properties">Properties</a></li>
                                </ul></li>
                                <li><a href="#scene">Scene</a></li>
                                <li><a href="#path-tracing">Path tracing</a>
                                <ul>
                                <li><a href="#russian-roulette-1">Russian Roulette 1</a></li>
                                <li><a href="#normals">Normals</a></li>
                                <li><a href="#reflection">Reflection</a></li>
                                </ul></li>
                                <li><a href="#image">Image</a>
                                <ul>
                                <li><a href="#writing-to-ppm">Writing to PPM</a></li>
                                </ul></li>
                                <li><a href="#main">Main</a>
                                <ul>
                                <li><a href="#argument-parsing">Argument parsing</a></li>
                                <li><a href="#the-main-file">The main file</a></li>
                                </ul></li>
                                <li><a href="#bibliography">References</a></li>
                                </ul>
                </nav></div>
        </div> 
</div>
<div class="footer">
</div>
<!-- <script>
function toggle_dark_mode() {
    var app = document.getElementsByTagName("BODY")[0];
    if (localStorage.darkMode == "dark") {
	localStorage.darkMode = "light";
	app.setAttribute("dark-mode", "light");
    } else {
	localStorage.darkMode = "dark";
	app.setAttribute("dark-mode", "dark");
    }
}
</script> -->
</body>
</html>
