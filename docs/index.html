<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>LiteratePT</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="theme.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">LiteratePT</h1>
<p class="subtitle">a translation of smallpt</p>
<!--        <div id="dark-mode-toggle">
                <p>Dark mode: <button class="dark-mode-button"
                        aria-label="Toggle dark mode"
                        onclick="toggle_dark_mode()">
                        <span></span><span></span>
                </button></p>
</div> -->
</header>
<div class="row">
        <div class="col-6 col-s-9" id="main">
<section id="literatept" class="level1">
<h1>LiteratePT</h1>
<p><a href="https://www.kevinbeason.com/smallpt/">SmallPT</a> by Kevin Beason is a global illumination ray tracer in 100 lines of C++. This is a translation into Rust; not in a 100 lines, but extremely literate. I’ve not tried to be compact at all. All the math and equations are explained, and I’ve tried to explain some concepts in Rust.</p>
<figure>
<img src="img/image.png" style="width:100%" alt="4000 spp rendering" /><figcaption aria-hidden="true">4000 spp rendering</figcaption>
</figure>
<p>This uses the following programming techniques:</p>
<ul>
<li>Property testing</li>
<li>Traits</li>
<li>Algebraic data types</li>
<li>Multi-threading using Rayon</li>
</ul>
<p>TODO:</p>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
Explain the sub-pixel sampling</li>
<li><input type="checkbox" disabled="" />
Explain use of Rayon in <code>Image::for_each</code></li>
<li><input type="checkbox" disabled="" />
Explain <code>RGBColour</code> structure</li>
<li><input type="checkbox" disabled="" checked="" />
Add command-line interface</li>
<li><input type="checkbox" disabled="" checked="" />
Fix performance issues with writing output</li>
<li><input type="checkbox" disabled="" checked="" />
Add proper progress bar</li>
<li><input type="checkbox" disabled="" checked="" />
Simplify recursion pattern</li>
</ul>
<div class="named-code-block">
<p>file:Cargo.toml</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">package</span><span class="kw">]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">name</span> <span class="op">=</span> <span class="st">&quot;literatept&quot;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">version</span> <span class="op">=</span> <span class="st">&quot;0.1.0&quot;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">authors</span> <span class="op">=</span> <span class="op">[</span><span class="st">&quot;Johan Hidding &lt;j.hidding@esciencecenter.nl&gt;&quot;</span><span class="op">]</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">edition</span> <span class="op">=</span> <span class="st">&quot;2018&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">profile</span><span class="kw">.</span><span class="dt">release</span><span class="kw">]</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">opt-level</span> <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">dependencies</span><span class="kw">]</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="er">&lt;&lt;dependencies&gt;&gt;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">dev-dependencies</span><span class="kw">]</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="er">&lt;&lt;dev-dependencies&gt;&gt;</span></span></code></pre></div>
</div>
<!-- > The package description can be extended using [more keys and their definitions](https://doc.rust-lang.org/cargo/reference/manifest.html) -->
<div class="named-code-block">
<p>«dependencies»</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">rand</span> <span class="op">=</span> <span class="st">&quot;0.8.5&quot;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">rayon</span> <span class="op">=</span> <span class="st">&quot;1.5.3&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">indicatif</span> <span class="op">=</span> <span class="op">{ </span><span class="dt">version</span><span class="op"> =</span> <span class="st">&quot;0.16.2&quot;</span><span class="op">, </span><span class="dt">features</span><span class="op"> =</span> <span class="op">[</span><span class="st">&quot;rayon&quot;</span><span class="op">]</span> <span class="op">}</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">argh</span> <span class="op">=</span> <span class="st">&quot;0.1.7&quot;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«imports»</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="kw">crate</span> rayon<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">rayon::prelude::</span><span class="op">*;</span></span></code></pre></div>
</div>
</section>
<section id="vectors" class="level1">
<h1>Vectors</h1>
<p><span class="math inline">\(\renewcommand{\vec}[1]{{\bf #1}}\)</span> The <code>Vec</code> type has three public members <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> and <span class="math inline">\(z\)</span>.</p>
<div class="named-code-block">
<p>file:src/vec3.rs</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Clone</span><span class="op">,</span><span class="bu">Copy</span><span class="op">,</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">struct</span> Vec3</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="kw">pub</span> x<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> <span class="kw">pub</span> y<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> <span class="kw">pub</span> z<span class="op">:</span> <span class="dt">f64</span> <span class="op">}</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const</span> <span class="kw">fn</span> vec(x<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> y<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> z<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> Vec3 <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    Vec3 <span class="op">{</span> x<span class="op">:</span> x<span class="op">,</span> y<span class="op">:</span> y<span class="op">,</span> z<span class="op">:</span> z <span class="op">}</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>We derive the <code>Clone</code>, <code>Copy</code>, and <code>Debug</code> traits, meaning that we can print debug statements involving <code>Vec</code> instances, and that we can clone instances usinge the <code>.clone()</code> method. The <code>Copy</code> trait means that the <code>Vec</code> can be copied implicitly, creating call-by-value semantics on this type.</p>
<section id="operators" class="level3">
<h3>Operators</h3>
<p>Each of the operators only occupy a single line of code in SmallPt, but this is probably better.</p>
<div class="named-code-block">
<p>«vector»</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Add</span> <span class="kw">for</span> Vec3 <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> add(<span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> <span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span> <span class="op">{</span> x<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>x <span class="op">+</span> other<span class="op">.</span>x</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>             <span class="op">,</span> y<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>y <span class="op">+</span> other<span class="op">.</span>y</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>             <span class="op">,</span> z<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>z <span class="op">+</span> other<span class="op">.</span>z <span class="op">}</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Sub</span> <span class="kw">for</span> Vec3 <span class="op">{</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> sub(<span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> <span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span> <span class="op">{</span> x<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>x <span class="op">-</span> other<span class="op">.</span>x</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>             <span class="op">,</span> y<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>y <span class="op">-</span> other<span class="op">.</span>y</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>             <span class="op">,</span> z<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>z <span class="op">-</span> other<span class="op">.</span>z <span class="op">}</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Neg</span> <span class="kw">for</span> Vec3 <span class="op">{</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> neg(<span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span><span class="pp">::</span>Output <span class="op">{</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span> <span class="op">{</span> x<span class="op">:</span> <span class="op">-</span><span class="kw">self</span><span class="op">.</span>x<span class="op">,</span> y<span class="op">:</span> <span class="op">-</span><span class="kw">self</span><span class="op">.</span>y<span class="op">,</span> z<span class="op">:</span> <span class="op">-</span><span class="kw">self</span><span class="op">.</span>z <span class="op">}</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>SmallPt defines four kinds of multiplication: scaling, point-wise multiplication, dot product and outer product. The point-wise multiplication is only used to manipulate colors, for which we’ll use separate structures.</p>
<p>Here’s scaling,</p>
<div class="named-code-block">
<p>«vector»</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Mul</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span> <span class="kw">for</span> Vec3 <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> mul(<span class="kw">self</span><span class="op">,</span> s<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span> <span class="op">{</span> x<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>x <span class="op">*</span> s</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>             <span class="op">,</span> y<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>y <span class="op">*</span> s</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>             <span class="op">,</span> z<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>z <span class="op">*</span> s <span class="op">}</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>the dot-product,</p>
<p><span class="math display">\[\vec{a} \cdot \vec{b} = a_x b_x + a_y b_y + a_z b_z\]</span></p>
<div class="named-code-block">
<p>«vector»</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Mul</span><span class="op">&lt;</span>Vec3<span class="op">&gt;</span> <span class="kw">for</span> Vec3 <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">f64</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> mul(<span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> <span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>x <span class="op">*</span> other<span class="op">.</span>x <span class="op">+</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>y <span class="op">*</span> other<span class="op">.</span>y <span class="op">+</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>z <span class="op">*</span> other<span class="op">.</span>z</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>and outer product for which we abuse the <code>%</code> operator,</p>
<p><span class="math display">\[\vec{a} \wedge \vec{b} = \det \begin{pmatrix}
\hat{x} &amp; \hat{y} &amp; \hat{z}\\
a_x &amp; a_y &amp; a_z \\
b_x &amp; b_y &amp; b_z
\end{pmatrix}\]</span></p>
<div class="named-code-block">
<p>«vector»</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Rem</span> <span class="kw">for</span> Vec3 <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> rem(<span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> <span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span> <span class="op">{</span> x<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>y <span class="op">*</span> other<span class="op">.</span>z <span class="op">-</span> <span class="kw">self</span><span class="op">.</span>z <span class="op">*</span> other<span class="op">.</span>y</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>             <span class="op">,</span> y<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>z <span class="op">*</span> other<span class="op">.</span>x <span class="op">-</span> <span class="kw">self</span><span class="op">.</span>x <span class="op">*</span> other<span class="op">.</span>z</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>             <span class="op">,</span> z<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>x <span class="op">*</span> other<span class="op">.</span>y <span class="op">-</span> <span class="kw">self</span><span class="op">.</span>y <span class="op">*</span> other<span class="op">.</span>x <span class="op">}</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>Vectors can be normalized to a unit-vector.</p>
<div class="named-code-block">
<p>«vector»</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Vec3 <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> abs(<span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">self</span> <span class="op">*</span> <span class="kw">self</span>)<span class="op">.</span>sqrt()</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> normalize(<span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span> <span class="op">*</span> (<span class="dv">1.0</span> <span class="op">/</span> <span class="kw">self</span><span class="op">.</span>abs())</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</section>
<section id="tests" class="level2">
<h2>Tests</h2>
<p>We use the <code>quickcheck</code> crate to do some property testing on the <code>Vec</code> type.</p>
<div class="named-code-block">
<p>«dev-dependencies»</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">quickcheck</span> <span class="op">=</span> <span class="st">&quot;1.0.3&quot;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="dt">quickcheck_macros</span> <span class="op">=</span> <span class="st">&quot;1.0.0&quot;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«import-quickcheck»</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="kw">crate</span> quickcheck<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>macro_use<span class="at">(</span>quickcheck<span class="at">)]</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="kw">crate</span> quickcheck_macros<span class="op">;</span></span></code></pre></div>
</div>
<p>We need to be able to generate <code>Arbitrary</code> instances of <code>Vec</code>. I’m not sure if this will ever yield a zero-vector, or a sequence of vectors that lie in the same plane.</p>
<div class="named-code-block">
<p>«vector-tests»</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Arbitrary <span class="kw">for</span> Vec3 <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> arbitrary<span class="op">&lt;</span>G<span class="op">:</span> Gen<span class="op">&gt;</span>(g<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> G) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="dt">f64</span><span class="pp">::</span>arbitrary(g)<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> y <span class="op">=</span> <span class="dt">f64</span><span class="pp">::</span>arbitrary(g)<span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> z <span class="op">=</span> <span class="dt">f64</span><span class="pp">::</span>arbitrary(g)<span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        vec(x<span class="op">,</span> y<span class="op">,</span> z)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>Now we can check that for any vectors <span class="math inline">\(\vec{a}\)</span> and <span class="math inline">\(\vec{b}\)</span>, we have,</p>
<p><span class="math display">\[(\vec{a} \wedge \vec{b}) \cdot \vec{a} = 0,\]</span></p>
<div class="named-code-block">
<p>«vector-tests»</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>quickcheck<span class="at">]</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> outer_product_orthogonal(a<span class="op">:</span> Vec3<span class="op">,</span> b<span class="op">:</span> Vec3) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> c <span class="op">=</span> a <span class="op">%</span> b<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    (a <span class="op">*</span> c)<span class="op">.</span>abs() <span class="op">&lt;</span> <span class="dv">1e-6</span> <span class="op">&amp;&amp;</span> (b <span class="op">*</span> c)<span class="op">.</span>abs() <span class="op">&lt;</span> <span class="dv">1e-6</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>that any normalized vector has length 1,</p>
<div class="named-code-block">
<p>«vector-tests»</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>quickcheck<span class="at">]</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> normalized_vec_length(a<span class="op">:</span> Vec3) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> (a <span class="op">*</span> a) <span class="op">==</span> <span class="dv">0.0</span> <span class="op">{</span> <span class="kw">return</span> <span class="cn">true</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> b <span class="op">=</span> a<span class="op">.</span>normalize()<span class="op">;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1.0</span> <span class="op">-</span> b <span class="op">*</span> b)<span class="op">.</span>abs() <span class="op">&lt;</span> <span class="dv">1e-6</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>and that the outer product upholds anti-symmetry,</p>
<p><span class="math display">\[\vec{a} \wedge \vec{b} = - \vec{b} \wedge \vec{a}.\]</span></p>
<div class="named-code-block">
<p>«vector-tests»</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>quickcheck<span class="at">]</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> outer_product_anti_symmetry(a<span class="op">:</span> Vec3<span class="op">,</span> b<span class="op">:</span> Vec3) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> c <span class="op">=</span> a <span class="op">%</span> b<span class="op">;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> d <span class="op">=</span> b <span class="op">%</span> a<span class="op">;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    (c <span class="op">+</span> d)<span class="op">.</span>abs() <span class="op">&lt;</span> <span class="dv">1e-6</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</section>
</section>
<section id="colour" class="level1">
<h1>Colour</h1>
<p>A sphere has material properties. We can choose between <em>diffuse</em>, <em>specular</em> and <em>refractive</em> type.</p>
<div class="named-code-block">
<p>«material»</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Reflection</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> Diffuse</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> Specular</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> Refractive <span class="op">}</span></span></code></pre></div>
</div>
<div class="alert alert-info">
<p>Note that the Rust <code>enum</code> types are much richer than the <code>enum</code> you may be used to from C/C++. Together with <code>struct</code>, <code>enum</code> gives the corner stones of <em>algebraic data types</em>. Where a <code>struct</code> collects different members into a <em>product type</em>, an <code>enum</code> is a <em>sum type</em>, meaning that it either contains one value or the other.</p>
</div>
<div class="named-code-block">
<p>file:src/colour.rs</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>inline<span class="at">]</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> clamp(x<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span> <span class="kw">if</span> x <span class="op">&lt;</span> <span class="dv">0</span><span class="op">.</span> <span class="op">{</span> <span class="dv">0</span><span class="op">.</span> <span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span> x <span class="op">&gt;</span> <span class="dv">1</span><span class="op">.</span> <span class="op">{</span> <span class="dv">1</span><span class="op">.</span> <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> x <span class="op">}</span> <span class="op">}</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">trait</span> Colour<span class="op">:</span> <span class="bu">Sized</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> <span class="pp">std::ops::</span><span class="bu">Add</span><span class="op">&lt;</span>Output<span class="op">=</span><span class="dt">Self</span><span class="op">&gt;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> <span class="pp">std::ops::</span><span class="bu">Mul</span><span class="op">&lt;</span>Output<span class="op">=</span><span class="dt">Self</span><span class="op">&gt;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> <span class="pp">std::ops::</span><span class="bu">Mul</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">,</span> Output<span class="op">=</span><span class="dt">Self</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> to_rgb(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> (<span class="dt">f64</span><span class="op">,</span> <span class="dt">f64</span><span class="op">,</span> <span class="dt">f64</span>)<span class="op">;</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> clamp(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> max(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (r<span class="op">,</span> g<span class="op">,</span> b) <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>to_rgb()<span class="op">;</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> r <span class="op">&gt;</span> g <span class="op">&amp;&amp;</span> r <span class="op">&gt;</span> b <span class="op">{</span> r <span class="op">}</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">if</span> g <span class="op">&gt;</span> b <span class="op">{</span> g <span class="op">}</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="op">{</span> b <span class="op">}</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> to_u24(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> (<span class="dt">u8</span><span class="op">,</span> <span class="dt">u8</span><span class="op">,</span> <span class="dt">u8</span>) <span class="op">{</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> to_int <span class="op">=</span> <span class="op">|</span>x<span class="op">|</span> (clamp(x)<span class="op">.</span>powf(<span class="dv">1</span><span class="op">./</span><span class="dv">2.2</span>) <span class="op">*</span> <span class="dv">255</span><span class="op">.</span> <span class="op">+</span> <span class="dv">0.5</span>)<span class="op">.</span>floor() <span class="kw">as</span> <span class="dt">u8</span><span class="op">;</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (r<span class="op">,</span> g<span class="op">,</span> b) <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>to_rgb()<span class="op">;</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>        (to_int(r)<span class="op">,</span> to_int(g)<span class="op">,</span> to_int(b))</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Clone</span><span class="op">,</span><span class="bu">Copy</span><span class="op">,</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">struct</span> RGBColour (<span class="dt">f64</span><span class="op">,</span> <span class="dt">f64</span><span class="op">,</span> <span class="dt">f64</span>)<span class="op">;</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const</span> <span class="kw">fn</span> rgb(r<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> g<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> b<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> RGBColour <span class="op">{</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>    RGBColour (r<span class="op">,</span> g<span class="op">,</span> b)</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const</span> BLACK<span class="op">:</span> RGBColour <span class="op">=</span> rgb(<span class="dv">0.0</span><span class="op">,</span> <span class="dv">0.0</span><span class="op">,</span> <span class="dv">0.0</span>)<span class="op">;</span></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const</span> WHITE<span class="op">:</span> RGBColour <span class="op">=</span> rgb(<span class="dv">1.0</span><span class="op">,</span> <span class="dv">1.0</span><span class="op">,</span> <span class="dv">1.0</span>)<span class="op">;</span></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Add</span> <span class="kw">for</span> RGBColour <span class="op">{</span></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> add(<span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> <span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> RGBColour(r1<span class="op">,</span>g1<span class="op">,</span>b1) <span class="op">=</span> <span class="kw">self</span><span class="op">;</span></span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> RGBColour(r2<span class="op">,</span>g2<span class="op">,</span>b2) <span class="op">=</span> other<span class="op">;</span></span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>        RGBColour(r1<span class="op">+</span>r2<span class="op">,</span>g1<span class="op">+</span>g2<span class="op">,</span>b1<span class="op">+</span>b2)</span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Mul</span> <span class="kw">for</span> RGBColour <span class="op">{</span></span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> mul(<span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> <span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> RGBColour(r1<span class="op">,</span>g1<span class="op">,</span>b1) <span class="op">=</span> <span class="kw">self</span><span class="op">;</span></span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> RGBColour(r2<span class="op">,</span>g2<span class="op">,</span>b2) <span class="op">=</span> other<span class="op">;</span></span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a>        RGBColour(r1<span class="op">*</span>r2<span class="op">,</span>g1<span class="op">*</span>g2<span class="op">,</span>b1<span class="op">*</span>b2)</span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-51"><a href="#cb17-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-52"><a href="#cb17-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-53"><a href="#cb17-53" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::ops::</span><span class="bu">Mul</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span> <span class="kw">for</span> RGBColour <span class="op">{</span></span>
<span id="cb17-54"><a href="#cb17-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb17-55"><a href="#cb17-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> mul(<span class="kw">self</span><span class="op">,</span> s<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb17-56"><a href="#cb17-56" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> RGBColour(r1<span class="op">,</span>g1<span class="op">,</span>b1) <span class="op">=</span> <span class="kw">self</span><span class="op">;</span></span>
<span id="cb17-57"><a href="#cb17-57" aria-hidden="true" tabindex="-1"></a>        RGBColour(r1<span class="op">*</span>s<span class="op">,</span>g1<span class="op">*</span>s<span class="op">,</span>b1<span class="op">*</span>s)</span>
<span id="cb17-58"><a href="#cb17-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-59"><a href="#cb17-59" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-60"><a href="#cb17-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-61"><a href="#cb17-61" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Colour <span class="kw">for</span> RGBColour <span class="op">{</span></span>
<span id="cb17-62"><a href="#cb17-62" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> to_rgb(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> (<span class="dt">f64</span><span class="op">,</span> <span class="dt">f64</span><span class="op">,</span> <span class="dt">f64</span>) <span class="op">{</span></span>
<span id="cb17-63"><a href="#cb17-63" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> RGBColour(r<span class="op">,</span> g<span class="op">,</span> b) <span class="op">=</span> <span class="kw">self</span><span class="op">;</span></span>
<span id="cb17-64"><a href="#cb17-64" aria-hidden="true" tabindex="-1"></a>        (<span class="op">*</span>r<span class="op">,</span> <span class="op">*</span>g<span class="op">,</span> <span class="op">*</span>b)</span>
<span id="cb17-65"><a href="#cb17-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-66"><a href="#cb17-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-67"><a href="#cb17-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> clamp(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb17-68"><a href="#cb17-68" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> RGBColour(r<span class="op">,</span> g<span class="op">,</span> b) <span class="op">=</span> <span class="kw">self</span><span class="op">;</span></span>
<span id="cb17-69"><a href="#cb17-69" aria-hidden="true" tabindex="-1"></a>        RGBColour(clamp(<span class="op">*</span>r)<span class="op">,</span> clamp(<span class="op">*</span>g)<span class="op">,</span> clamp(<span class="op">*</span>b))</span>
<span id="cb17-70"><a href="#cb17-70" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-71"><a href="#cb17-71" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</section>
<section id="geometry" class="level1">
<h1>Geometry</h1>
<p>With floating-point calculations, round-off can become a problem. If we bounce a ray off a sphere, how do we make sure that we don’t detect another intersection with the same sphere? One way is to make sure that every ray travels a mininum distance before bouncing off anything. We’ll call this distance <code>EPS</code>, short for <em>epsilon</em>, being the greek letter <span class="math inline">\(\epsilon\)</span>, generally denoting small quantities.</p>
<div class="named-code-block">
<p>«constants»</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> EPS<span class="op">:</span> <span class="dt">f64</span> <span class="op">=</span> <span class="dv">1e-4</span><span class="op">;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> SAMPLES<span class="op">:</span> <span class="dt">usize</span> <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> WIDTH<span class="op">:</span> <span class="dt">usize</span> <span class="op">=</span> <span class="dv">640</span><span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> HEIGHT<span class="op">:</span> <span class="dt">usize</span> <span class="op">=</span> <span class="dv">480</span><span class="op">;</span></span></code></pre></div>
</div>
<p>We now define the <code>Ray</code> and <code>Sphere</code> types.</p>
<div class="named-code-block">
<p>«ray»</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Ray</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="kw">pub</span> origin<span class="op">:</span> Vec3</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> <span class="kw">pub</span> direction<span class="op">:</span> Vec3 <span class="op">}</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«sphere»</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Sphere</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="kw">pub</span> radius<span class="op">:</span> <span class="dt">f64</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> <span class="kw">pub</span> position<span class="op">:</span> Vec3</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>sphere<span class="op">-</span>members<span class="op">&gt;&gt;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
</div>
<p>The <code>Shpere</code> has a method to detect intersection with a <code>Ray</code>.</p>
<div class="named-code-block">
<p>«sphere»</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Sphere <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> intersect(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> ray<span class="op">:</span> <span class="op">&amp;</span>Ray) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span>sphere<span class="op">-</span>ray<span class="op">-</span>intersect<span class="op">&gt;&gt;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>The equation for the surface of a sphere at position <span class="math inline">\(\vec{p}\)</span> and radius <span class="math inline">\(r\)</span> is,</p>
<p><span class="math display">\[S:\ (\vec{p} - \vec{x})^2 = r^2,\]</span>{#eq:sphere}</p>
<p>and a ray from origin <span class="math inline">\(\vec{o}\)</span> and direction <span class="math inline">\(\vec{\hat{d}}\)</span> describes the half-line,</p>
<p><span class="math display">\[L:\ \vec{x} = \vec{o} + t\vec{\hat{d}}.\]</span>{#eq:ray}</p>
<p>Equating these gives a quadratic equation for <span class="math inline">\(t\)</span>, taking <span class="math inline">\(\vec{q} = \vec{p} - \vec{o}\)</span>,</p>
<p><span class="math display">\[\begin{align}
S \cap L:\ &amp;(\vec{p} - \vec{o} - t\vec{\hat{d}})^2 = r^2\\
           &amp;t^2 - 2t\vec{\hat{d}}\vec{q} + \vec{q}^2 - r^2 = 0\\
           &amp;t = \vec{\hat{d}}\vec{q} \pm \sqrt{(\vec{\hat{d}}\vec{q})^2 - \vec{q}^2 + r^2}.
\end{align}\]</span>{#eq:sphere-ray-intersect}</p>
<p>We first compute the determinant (part under the square root),</p>
<div class="named-code-block">
<p>«sphere-ray-intersect»</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> q <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>position <span class="op">-</span> ray<span class="op">.</span>origin<span class="op">;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> b <span class="op">=</span> ray<span class="op">.</span>direction <span class="op">*</span> q<span class="op">;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> r <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>radius<span class="op">;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> det <span class="op">=</span> b<span class="op">*</span>b <span class="op">-</span> q<span class="op">*</span>q <span class="op">+</span> r<span class="op">*</span>r<span class="op">;</span></span></code></pre></div>
</div>
<p>If it is negative, there is no solution and the ray does not intersect with the sphere.</p>
<div class="named-code-block">
<p>«sphere-ray-intersect»</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> det <span class="op">&lt;</span> <span class="dv">0</span><span class="op">.</span> <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="cn">None</span><span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>Otherwise, it is safe to compute the square-root and return the first intersection at a distance larger than <code>EPS</code>.</p>
<div class="named-code-block">
<p>«sphere-ray-intersect»</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> rdet <span class="op">=</span> det<span class="op">.</span>sqrt()<span class="op">;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> b <span class="op">-</span> rdet <span class="op">&gt;</span> EPS <span class="op">{</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Some</span>(b <span class="op">-</span> rdet)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span> b <span class="op">+</span> rdet <span class="op">&gt;</span> EPS <span class="op">{</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Some</span>(b <span class="op">+</span> rdet)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="cn">None</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</section>
<section id="scene" class="level1">
<h1>Scene</h1>
<p>The scene in SmallPt is an adaptation of the Cornell box.</p>
<div class="named-code-block">
<p>«sphere-members»</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> <span class="kw">pub</span> emission<span class="op">:</span> RGBColour</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> <span class="kw">pub</span> colour<span class="op">:</span> RGBColour</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> <span class="kw">pub</span> reflection<span class="op">:</span> Reflection</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«scene»</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> SPHERES<span class="op">:</span> [Sphere<span class="op">;</span><span class="dv">9</span>] <span class="op">=</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>scene<span class="op">-</span>spheres<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>The scene consists of a red ceiling,</p>
<div class="named-code-block">
<p>«scene-spheres»</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>[ Sphere <span class="op">{</span> radius<span class="op">:</span>  <span class="dv">1e5</span><span class="op">,</span>  position<span class="op">:</span> vec(<span class="dv">1e5</span><span class="op">+</span><span class="dv">1</span><span class="op">.,</span>   <span class="dv">40.8</span><span class="op">,</span> <span class="dv">81.6</span>)<span class="op">,</span> emission<span class="op">:</span> BLACK</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> colour<span class="op">:</span> rgb(<span class="dv">0.75</span><span class="op">,</span> <span class="dv">0.25</span><span class="op">,</span> <span class="dv">0.25</span>)<span class="op">,</span> reflection<span class="op">:</span> <span class="pp">Reflection::</span>Diffuse <span class="op">}</span></span></code></pre></div>
</div>
<p>four grey walls, one of which is black to emulate photons escaping,</p>
<div class="named-code-block">
<p>«scene-spheres»</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> Sphere <span class="op">{</span> radius<span class="op">:</span>  <span class="dv">1e5</span><span class="op">,</span>  position<span class="op">:</span> vec(<span class="dv">50</span><span class="op">.,</span> <span class="dv">40.8</span><span class="op">,</span> <span class="dv">1e5</span>)<span class="op">,</span>       emission<span class="op">:</span> BLACK</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> colour<span class="op">:</span> rgb(<span class="dv">0.75</span><span class="op">,</span> <span class="dv">0.75</span><span class="op">,</span> <span class="dv">0.75</span>)<span class="op">,</span> reflection<span class="op">:</span> <span class="pp">Reflection::</span>Diffuse <span class="op">}</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> Sphere <span class="op">{</span> radius<span class="op">:</span>  <span class="dv">1e5</span><span class="op">,</span>  position<span class="op">:</span> vec(<span class="dv">50</span><span class="op">.,</span> <span class="dv">40.8</span><span class="op">,</span> <span class="op">-</span><span class="dv">1e5</span><span class="op">+</span><span class="dv">170</span><span class="op">.</span>)<span class="op">,</span>  emission<span class="op">:</span> BLACK</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> colour<span class="op">:</span> BLACK<span class="op">,</span>                 reflection<span class="op">:</span> <span class="pp">Reflection::</span>Diffuse <span class="op">}</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> Sphere <span class="op">{</span> radius<span class="op">:</span>  <span class="dv">1e5</span><span class="op">,</span>  position<span class="op">:</span> vec(<span class="dv">50</span><span class="op">.,</span> <span class="dv">1e5</span><span class="op">,</span> <span class="dv">81.6</span>)<span class="op">,</span>       emission<span class="op">:</span> BLACK</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> colour<span class="op">:</span> rgb(<span class="dv">0.75</span><span class="op">,</span> <span class="dv">0.75</span><span class="op">,</span> <span class="dv">0.75</span>)<span class="op">,</span> reflection<span class="op">:</span> <span class="pp">Reflection::</span>Diffuse <span class="op">}</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> Sphere <span class="op">{</span> radius<span class="op">:</span>  <span class="dv">1e5</span><span class="op">,</span>  position<span class="op">:</span> vec(<span class="dv">50</span><span class="op">.,</span> <span class="op">-</span><span class="dv">1e5</span><span class="op">+</span><span class="dv">81.6</span><span class="op">,</span> <span class="dv">81.6</span>)<span class="op">,</span> emission<span class="op">:</span> BLACK</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> colour<span class="op">:</span> rgb(<span class="dv">0.75</span><span class="op">,</span> <span class="dv">0.75</span><span class="op">,</span> <span class="dv">0.75</span>)<span class="op">,</span> reflection<span class="op">:</span> <span class="pp">Reflection::</span>Diffuse <span class="op">}</span></span></code></pre></div>
</div>
<p>a blue floor,</p>
<div class="named-code-block">
<p>«scene-spheres»</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> Sphere <span class="op">{</span> radius<span class="op">:</span>  <span class="dv">1e5</span><span class="op">,</span>  position<span class="op">:</span> vec(<span class="op">-</span><span class="dv">1e5</span><span class="op">+</span><span class="dv">99</span><span class="op">.,</span> <span class="dv">40.8</span><span class="op">,</span> <span class="dv">81.6</span>)<span class="op">,</span> emission<span class="op">:</span> BLACK</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> colour<span class="op">:</span> rgb(<span class="dv">0.25</span><span class="op">,</span> <span class="dv">0.25</span><span class="op">,</span> <span class="dv">0.75</span>)<span class="op">,</span> reflection<span class="op">:</span> <span class="pp">Reflection::</span>Diffuse <span class="op">}</span></span></code></pre></div>
</div>
<p>a glass and a metal sphere,</p>
<div class="named-code-block">
<p>«scene-spheres»</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> Sphere <span class="op">{</span> radius<span class="op">:</span> <span class="dv">16.5</span><span class="op">,</span>  position<span class="op">:</span> vec(<span class="dv">27</span><span class="op">.,</span> <span class="dv">16.5</span><span class="op">,</span> <span class="dv">47</span><span class="op">.</span>)<span class="op">,</span> emission<span class="op">:</span> BLACK</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> colour<span class="op">:</span> rgb(<span class="dv">0.999</span><span class="op">,</span> <span class="dv">0.999</span><span class="op">,</span> <span class="dv">0.999</span>)<span class="op">,</span> reflection<span class="op">:</span> <span class="pp">Reflection::</span>Specular <span class="op">}</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> Sphere <span class="op">{</span> radius<span class="op">:</span> <span class="dv">16.5</span><span class="op">,</span>  position<span class="op">:</span> vec(<span class="dv">73</span><span class="op">.,</span> <span class="dv">16.5</span><span class="op">,</span> <span class="dv">78</span><span class="op">.</span>)<span class="op">,</span> emission<span class="op">:</span> BLACK</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> colour<span class="op">:</span> rgb(<span class="dv">0.999</span><span class="op">,</span> <span class="dv">0.999</span><span class="op">,</span> <span class="dv">0.999</span>)<span class="op">,</span> reflection<span class="op">:</span> <span class="pp">Reflection::</span>Refractive <span class="op">}</span></span></code></pre></div>
</div>
<p>and a plafonniere</p>
<div class="named-code-block">
<p>«scene-spheres»</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> Sphere <span class="op">{</span> radius<span class="op">:</span>  <span class="dv">600</span><span class="op">.,</span>  position<span class="op">:</span> vec(<span class="dv">50</span><span class="op">.,</span> <span class="dv">681.6</span><span class="op">-</span><span class="dv">0.27</span><span class="op">,</span> <span class="dv">81.6</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> emission<span class="op">:</span> rgb(<span class="dv">12.0</span><span class="op">,</span> <span class="dv">12.0</span><span class="op">,</span> <span class="dv">12.0</span>)<span class="op">,</span> colour<span class="op">:</span> BLACK</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> reflection<span class="op">:</span> <span class="pp">Reflection::</span>Diffuse <span class="op">}</span> ]<span class="op">;</span></span></code></pre></div>
</div>
<p>Given this scene, we can define the function <code>intersect</code> which computes the first intersection of a ray with any of the objects in the scene. If the ray intersects, a tuple is returned giving the distance and reference to the obstructing object.</p>
<div class="named-code-block">
<p>«scene»</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> intersect(ray<span class="op">:</span> <span class="op">&amp;</span>Ray) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>(<span class="dt">f64</span><span class="op">,</span> <span class="op">&amp;</span><span class="ot">&#39;static</span> Sphere)<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> result <span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span>(<span class="dt">f64</span><span class="op">,</span> <span class="op">&amp;</span>Sphere)<span class="op">&gt;</span> <span class="op">=</span> <span class="cn">None</span><span class="op">;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> s <span class="kw">in</span> <span class="op">&amp;</span>SPHERES <span class="op">{</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(d) <span class="op">=</span> s<span class="op">.</span>intersect(ray) <span class="op">{</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> result<span class="op">.</span>is_none() <span class="op">||</span> result<span class="op">.</span>unwrap()<span class="op">.</span><span class="dv">0</span> <span class="op">&gt;</span> d <span class="op">{</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>                result <span class="op">=</span> <span class="cn">Some</span>((d<span class="op">,</span> s))<span class="op">;</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    result</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>It feel like we’ve done a lot of work here, but we’ve only arrived at line 48 of SmallPt.</p>
</section>
<section id="path-tracing" class="level1">
<h1>Path tracing</h1>
<p>This is where all the physics happens. We need to generate random numbers.</p>
<div class="named-code-block">
<p>«import-rand»</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="kw">crate</span> rand<span class="op">;</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">rand::</span>Rng<span class="op">;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«constants»</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::</span><span class="dt">f64</span><span class="pp">::consts::</span>PI<span class="op">;</span></span></code></pre></div>
</div>
<p>The <code>radiance</code> function computes how many photons are traveling at a certain position in space from a certain direction.</p>
<div class="named-code-block">
<p>«path-tracing»</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> radiance(ray<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Ray<span class="op">,</span> <span class="kw">mut</span> depth<span class="op">:</span> <span class="dt">u16</span>) <span class="op">-&gt;</span> RGBColour <span class="op">{</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> rng <span class="op">=</span> <span class="pp">rand::</span>thread_rng()<span class="op">;</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> colour <span class="op">=</span> WHITE<span class="op">;</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> output <span class="op">=</span> BLACK<span class="op">;</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">loop</span> <span class="op">{</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span><span class="kw">do</span><span class="op">-</span>intersect<span class="op">&gt;&gt;</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span>russian<span class="op">-</span>roulette<span class="op">-</span><span class="dv">1</span><span class="op">&gt;&gt;</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span>compute<span class="op">-</span>normal<span class="op">&gt;&gt;</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span><span class="kw">do</span><span class="op">-</span>reflect<span class="op">&gt;&gt;</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>The second argument keeps track of how deep we are tracing. It is used as a control to switch between sampling methods. One method is to reduce the brightness of the ray at every reflection off a diffuse object until we hit a light source. The second method, also known as <em>Russion Roulette</em>, is to keep the brightness of the ray constant, but only reflect with a probability given by the colour of the object. The first method will always give a nice smooth image but may take a long time wasted on very dim rays. The Russian Roulette wastes less time per sample, but produces grainy images at low sample rates. That is why SmallPt switches sampling methods if we are deeper than <span class="math inline">\(n\)</span> reflections.</p>
<blockquote>
<p>One major change with respect to the original SmallPT is the recursion. SmallPT uses true recursion to compute the radiance of a ray. In Rust, this has led to some instances where a stack overflow was triggered. We may use a stack based implementation to prevent this from happening. The result of each recursive radiance computation goes into an affine transformation (<span class="math inline">\(ax + b\)</span>). We may compose two transformations</p>
<p><span class="math display">\[(x \to ax + b) \circ (y \to cy + d) = (y \to a(cy + d) + b = acy + ad + b,\]</span></p>
<p>meaning that if we express an affine transformation as a pair <span class="math inline">\((a, b)\)</span> and a second <span class="math inline">\((c, d)\)</span>, we have <span class="math inline">\((a, b) \circ (c, d) = (ac, ad + b)\)</span>. This means we have a compact way to codify the contribution of each scattered ray.</p>
</blockquote>
<p>First, we need to see if the ray intersects any object in the scene; if not, we return the colour <code>BLACK</code>.</p>
<div class="named-code-block">
<p>«do-intersect»</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> hit <span class="op">=</span> intersect(<span class="op">&amp;</span>ray)<span class="op">;</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> hit<span class="op">.</span>is_none() <span class="op">{</span> <span class="kw">return</span> output<span class="op">;</span> <span class="op">}</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (distance<span class="op">,</span> object) <span class="op">=</span> hit<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> output <span class="op">+</span> object<span class="op">.</span>emission <span class="op">*</span> colour<span class="op">;</span></span></code></pre></div>
</div>
<section id="russian-roulette-1" class="level2">
<h2>Russian Roulette 1</h2>
<p>The colour <span class="math inline">\(f\)</span> of an object reduces the radiance of a ray compared to the radiance of the reflected ray.</p>
<p><span class="math display">\[r = f r_{\rm refl}.\]</span>{#eq:reflected-radiance}</p>
<p>The first Russian Roulette happens at an integration depth of 5. The value <span class="math inline">\(p\)</span> is the probability of the ray being reflected. The value of <span class="math inline">\(p\)</span> can be anything between <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>, and the math would still work out, however we choose it to be the maximum value of the colour of the object. Once the ray has overcome the odds of being absorbed, we have to renormalize the colour. If <span class="math inline">\(p = 1\)</span> the colour should remain the same. In other words,</p>
<p><span class="math display">\[r = \frac{1}{N}\sum_{\rm N} p f&#39; r_{\rm refl} = f r_{\rm refl},\]</span>{#eq:russian-roulette}</p>
<p>meaning that <span class="math display">\[f&#39; = f / p\]</span>. If the ray got absorbed, the radiance equals the emission of the object.</p>
<div class="named-code-block">
<p>«russian-roulette-1»</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> f <span class="op">=</span> object<span class="op">.</span>colour<span class="op">;</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> p <span class="op">=</span> f<span class="op">.</span>max()<span class="op">;</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>depth <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> depth <span class="op">&gt;</span> <span class="dv">5</span> <span class="op">{</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> rng<span class="op">.</span><span class="pp">gen::</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span>() <span class="op">&lt;</span> p <span class="op">{</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>        f <span class="op">=</span> f <span class="op">*</span> (<span class="dv">1</span><span class="op">.</span> <span class="op">/</span> p)<span class="op">;</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> output<span class="op">;</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// current = stack.pop();</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// continue;</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</section>
<section id="normals" class="level2">
<h2>Normals</h2>
<p>Now that we know that we hit an object, we need to compute the normal vector. Let <span class="math inline">\(x\)</span> be the position where the ray hits the object, and <span class="math inline">\(\vec{n}\)</span> be the normal vector (outward pointing) of the object.</p>
<div class="named-code-block">
<p>«compute-normal»</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="op">=</span> ray<span class="op">.</span>origin <span class="op">+</span> ray<span class="op">.</span>direction <span class="op">*</span> distance<span class="op">;</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> n <span class="op">=</span> (x <span class="op">-</span> object<span class="op">.</span>position)<span class="op">.</span>normalize()<span class="op">;</span></span></code></pre></div>
</div>
<p>It could be that we’re inside the object. In that case, the normal of reflection is opposite the normal of the object.</p>
<div class="named-code-block">
<p>«compute-normal»</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> n_refl <span class="op">=</span> <span class="kw">if</span> n <span class="op">*</span> ray<span class="op">.</span>direction <span class="op">&lt;</span> <span class="dv">0</span><span class="op">.</span> <span class="op">{</span> n <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> <span class="op">-</span>n <span class="op">};</span></span></code></pre></div>
</div>
</section>
<section id="reflection" class="level2">
<h2>Reflection</h2>
<p>We’re at the point that we need to compute how much light is reflected. Of course, this depends on the type of material that the object is made of. SmallPt has three material types, <em>diffuse</em>, <em>specular</em>, and <em>refractive</em>, that each have their own physics.</p>
<div class="named-code-block">
<p>«do-reflect»</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> object<span class="op">.</span>reflection <span class="op">{</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">Reflection::</span>Diffuse <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span>diffuse<span class="op">-</span>reflection<span class="op">&gt;&gt;</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">Reflection::</span>Specular <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span>specular<span class="op">-</span>reflection<span class="op">&gt;&gt;</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">Reflection::</span>Refractive <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span>refractive<span class="op">-</span>reflection<span class="op">&gt;&gt;</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
</div>
<section id="diffuse" class="level3">
<h3>Diffuse</h3>
<p>There are many types of diffuse reflection. You could imagine a surface where rays have equal probability of reflecting to any direction. This would mean sampling vectors on a hemisphere. We have a uniform probability over longitude:</p>
<div class="named-code-block">
<p>«diffuse-reflection»</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> phi <span class="op">=</span> <span class="dv">2</span><span class="op">.*</span>PI <span class="op">*</span> rng<span class="op">.</span><span class="pp">gen::</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span>()<span class="op">;</span></span></code></pre></div>
</div>
<p>Taking <span class="math inline">\(\theta\)</span> to be the angle of incidence to the normal of the surface, we have a <span class="math inline">\(p(\theta) \sim \sin \theta\)</span> probability over latitude. The inverse CDF sampling method then gives than <span class="math inline">\(\cos \theta\)</span> has a uniform distribution in the interval <span class="math inline">\([0, 1]\)</span>.</p>
<p>However, there is a second effect. If you shine a uniform bundle of light on a surface at an angle, the light intensity drops with a factor <span class="math inline">\(\cos \theta\)</span>. The combination of sampling the hemisphere and the lighting is known has <em>cosine-weighted sampling</em>, and there is a trick called <em>Malley’s Method</em>. We can sample points on a uniform disc, and project those onto the hemisphere <span class="citation" data-cites="Pbr-13.6.3">[@Pbr-13.6.3]</span>.</p>
<p>On a disc we have <span class="math inline">\(p(r) \sim r\)</span>, so <span class="math inline">\(p(r^2) \sim 1\)</span>,</p>
<div class="named-code-block">
<p>«diffuse-reflection»</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> r2 <span class="op">:</span> <span class="dt">f64</span> <span class="op">=</span> rng<span class="op">.</span>gen()<span class="op">;</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> r <span class="op">=</span> r2<span class="op">.</span>sqrt()<span class="op">;</span></span></code></pre></div>
</div>
<p>We need a set of orthogonal axes in the plane of reflection. We pick a vector to start with, and compute the outer product with the normal to give one vector <span class="math inline">\(\vec{u}\)</span> orthogonal to <span class="math inline">\(\vec{n}\)</span>. To prevent numberloss, the first vector should not be too close to the normal. The second vector <span class="math inline">\(\vec{v}\)</span> is found by taking another outer product of <span class="math inline">\(\vec{u} \times \vec{n}\)</span>.</p>
<div class="named-code-block">
<p>«diffuse-reflection»</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ncl <span class="op">=</span> <span class="kw">if</span> n_refl<span class="op">.</span>x<span class="op">.</span>abs() <span class="op">&gt;</span> <span class="dv">0.1</span> <span class="op">{</span> vec(<span class="dv">0</span><span class="op">.,</span> <span class="dv">1</span><span class="op">.,</span> <span class="dv">0</span><span class="op">.</span>) <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> vec(<span class="dv">1</span><span class="op">.,</span> <span class="dv">0</span><span class="op">.,</span> <span class="dv">0</span><span class="op">.</span>) <span class="op">};</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> u <span class="op">=</span> (ncl <span class="op">%</span> n_refl)<span class="op">.</span>normalize()<span class="op">;</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> v <span class="op">=</span> n_refl <span class="op">%</span> u<span class="op">;</span></span></code></pre></div>
</div>
<p>The direction of the reflected ray is now known.</p>
<div class="named-code-block">
<p>«diffuse-reflection»</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> d <span class="op">=</span> (u<span class="op">*</span>phi<span class="op">.</span>cos()<span class="op">*</span>r <span class="op">+</span> v<span class="op">*</span>phi<span class="op">.</span>sin()<span class="op">*</span>r <span class="op">+</span> n_refl<span class="op">*</span>(<span class="dv">1</span><span class="op">.-</span>r2)<span class="op">.</span>sqrt())<span class="op">.</span>normalize()<span class="op">;</span></span></code></pre></div>
</div>
<p>To compute the radiance, we need to know the radiance from the reflected ray.</p>
<div class="named-code-block">
<p>«diffuse-reflection»</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>ray <span class="op">=</span> Ray <span class="op">{</span>origin<span class="op">:</span> x<span class="op">,</span> direction<span class="op">:</span> d<span class="op">};</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>colour <span class="op">=</span> f <span class="op">*</span> colour<span class="op">;</span></span></code></pre></div>
</div>
</section>
<section id="specular" class="level3">
<h3>Specular</h3>
<p>Specular reflection means we have to mirror the incident ray with respect to the normal. This means that only the <span class="math inline">\(\vec{n}\)</span> component of the direction flips,</p>
<p><span class="math display">\[\vec{\hat{d}}&#39; = \vec{\hat{d}} - 2 \vec{\hat{n}} (\vec{\hat{n}} \cdot \vec{\hat{d}})\]</span>.</p>
<div class="named-code-block">
<p>«specular-reflection»</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> d <span class="op">=</span> ray<span class="op">.</span>direction <span class="op">-</span> n <span class="op">*</span> <span class="dv">2</span><span class="op">.*</span>(n<span class="op">*</span>ray<span class="op">.</span>direction)<span class="op">;</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>ray <span class="op">=</span> Ray <span class="op">{</span>origin<span class="op">:</span> x<span class="op">,</span> direction<span class="op">:</span> d<span class="op">};</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>colour <span class="op">=</span> f <span class="op">*</span> colour<span class="op">;</span></span></code></pre></div>
</div>
</section>
<section id="refractive" class="level3">
<h3>Refractive</h3>
<p>Now some real optics! Discarding polarisation, there are several ways a photon may go at the boundary between two transparent media: <em>total internal reflection</em>, <em>refraction</em>, or <em>partial reflection</em>.</p>
<p>There is always a reflective component,</p>
<div class="named-code-block">
<p>«refractive-reflection»</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> d <span class="op">=</span> ray<span class="op">.</span>direction <span class="op">-</span> n <span class="op">*</span> <span class="dv">2</span><span class="op">.*</span>(n<span class="op">*</span>ray<span class="op">.</span>direction)<span class="op">;</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> reflected_ray <span class="op">=</span> Ray <span class="op">{</span> origin<span class="op">:</span> x<span class="op">,</span> direction<span class="op">:</span> d <span class="op">};</span></span></code></pre></div>
</div>
<p>We need to know if we’re moving into or out of the object.</p>
<div class="named-code-block">
<p>«refractive-reflection»</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> into <span class="op">=</span> n <span class="op">*</span> n_refl <span class="op">&gt;</span> <span class="dv">0</span><span class="op">.;</span></span></code></pre></div>
</div>
<section id="refractive-index" class="level4">
<h4>Refractive index</h4>
<p>The refractive index of glass can vary, but <span class="math inline">\(n = 1.5\)</span> seems reasonable.</p>
<div class="named-code-block">
<p>«constants»</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> N_GLASS<span class="op">:</span> <span class="dt">f64</span> <span class="op">=</span> <span class="dv">1.5</span><span class="op">;</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> N_AIR<span class="op">:</span> <span class="dt">f64</span> <span class="op">=</span> <span class="dv">1.0</span><span class="op">;</span></span></code></pre></div>
</div>
<p>Depending on whether we’re entering or leaving the glass object, the effective index of refraction is <span class="math inline">\(n_{\rm air} / n_{\rm glass}\)</span> or <span class="math inline">\(n_{\rm glass} / n_{\rm air}\)</span>.</p>
<div class="named-code-block">
<p>«refractive-reflection»</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> n_eff <span class="op">=</span> <span class="kw">if</span> into <span class="op">{</span> N_AIR <span class="op">/</span> N_GLASS <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> N_GLASS <span class="op">/</span> N_AIR <span class="op">};</span></span></code></pre></div>
</div>
</section>
<section id="total-internal-reflection" class="level4">
<h4>Total internal reflection</h4>
<p>Total internal reflection happens if the angle of incidence is larger than some critical angle <span class="math inline">\(\theta_c\)</span>, given by</p>
<p><span class="math display">\[\theta_c = \arcsin \frac{n_{\rm outside}}{n_{\rm inside}}.\]</span>{#eq:tir-critical-angle}</p>
<p>We can easily compute <span class="math inline">\(\mu = \cos \theta\)</span> using the inner product, so with a little algebra, total-internal-reflection happens if,</p>
<p><span class="math display">\[\begin{align}
\sin \theta &amp;&gt; {n_o \over n_i}\\
\sqrt{1 - \cos^2 \theta} &amp;&gt; {n_o \over n_i}\\
1 - \mu^2 &amp;&gt; \left({n_o \over n_i}\right)^2\\
n_{\rm eff}^2 \left(1 - \mu^2\right) &amp;&gt; 1
\end{align}\]</span></p>
<div class="named-code-block">
<p>«refractive-reflection»</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mu <span class="op">=</span> ray<span class="op">.</span>direction <span class="op">*</span> n_refl<span class="op">;</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cos2t <span class="op">=</span> <span class="dv">1</span><span class="op">.</span> <span class="op">-</span> n_eff<span class="op">*</span>n_eff<span class="op">*</span>(<span class="dv">1</span><span class="op">.</span> <span class="op">-</span> mu<span class="op">*</span>mu)<span class="op">;</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> cos2t <span class="op">&lt;</span> <span class="dv">0</span><span class="op">.</span> <span class="op">{</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>total<span class="op">-</span>internal<span class="op">-</span>reflection<span class="op">&gt;&gt;</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>partial<span class="op">-</span>reflection<span class="op">&gt;&gt;</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>In that case, we recurse with the reflected ray.</p>
<div class="named-code-block">
<p>«total-internal-reflection»</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>ray <span class="op">=</span> reflected_ray<span class="op">;</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>colour <span class="op">=</span> f <span class="op">*</span> colour<span class="op">;</span></span></code></pre></div>
</div>
</section>
<section id="partial-reflection" class="level4">
<h4>Partial reflection</h4>
<p>In the case of partial reflection, we need to compute also the angle of the refracted ray. We have Snell’s law,</p>
<p><span class="math display">\[{\sin \theta_i \over \sin \theta_o} = {n_o \over n_i} = {1 \over n_{\rm eff}}.\]</span>{#eq:snellius}</p>
<p>We can decompose the incident ray direction into a normal component <span class="math inline">\(d_n\)</span> and a transverse component <span class="math inline">\(d_t\)</span>. Then <span class="math inline">\(|d_t| = \sin \theta_i\)</span>, and <span class="math inline">\(|d_n| = \vec{d} \cdot \vec{n} = \cos \theta_i\)</span>. Similarly we can decompose the outgoing ray direction <span class="math inline">\(\vec{d}&#39;\)</span>,</p>
<p><span class="math display">\[\begin{align}
d_t&#39; &amp;= n_{\rm eff} (\vec{d} - \mu \vec{n})\\
d_n&#39; &amp;= \sqrt{1 - n_{\rm eff}^2 |d_t|^2} \vec{n},
\end{align}\]</span></p>
<p>where <span class="math inline">\(|d_t|^2 = 1 - \mu^2\)</span>. That is convenient, because it turns out we have already computed <span class="math inline">\(|d_n&#39;|\)</span>, it is the square root of <code>cos2t</code>. Now, we also see where the total internal reflection comes from; there is no solution to Snell’s law for those angles.</p>
<div class="named-code-block">
<p>«partial-reflection»</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tdir <span class="op">=</span> (ray<span class="op">.</span>direction <span class="op">*</span> n_eff <span class="op">-</span> n_refl <span class="op">*</span> (mu<span class="op">*</span>n_eff <span class="op">+</span> cos2t<span class="op">.</span>sqrt()))<span class="op">.</span>normalize()<span class="op">;</span></span></code></pre></div>
</div>
<p>Next, we need to compute the fraction of light that is reflected. The Fresnel equations describe this process, but they are very complicated and also deal with polarisation. We use Schlick’s approximation instead <span class="citation" data-cites="Schlick1994">[@Schlick1994]</span>,</p>
<p><span class="math display">\[R(\theta) = R_0 + (1 - R_0) (1 - \mu)^5,\]</span></p>
<p>where</p>
<p><span class="math display">\[R_0 = \left(\frac{n_i - n_o}{n_i + n_o}\right)^2.\]</span></p>
<div class="named-code-block">
<p>«constants»</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> R0<span class="op">:</span> <span class="dt">f64</span> <span class="op">=</span>  (N_GLASS <span class="op">-</span> N_AIR) <span class="op">*</span> (N_GLASS <span class="op">-</span> N_AIR)</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>              <span class="op">/</span> ((N_GLASS <span class="op">+</span> N_AIR) <span class="op">*</span> (N_GLASS <span class="op">+</span> N_AIR))<span class="op">;</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«partial-reflection»</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c <span class="op">=</span> <span class="dv">1</span><span class="op">.</span> <span class="op">-</span> (<span class="kw">if</span> into <span class="op">{</span> <span class="op">-</span>mu <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span>tdir <span class="op">*</span> n<span class="op">}</span>)<span class="op">;</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> re <span class="op">=</span> R0 <span class="op">+</span> (<span class="dv">1</span><span class="op">.</span> <span class="op">-</span> R0) <span class="op">*</span> c<span class="op">.</span>powf(<span class="dv">5.0</span>)<span class="op">;</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tr <span class="op">=</span> <span class="dv">1</span><span class="op">.</span> <span class="op">-</span> re<span class="op">;</span></span></code></pre></div>
</div>
</section>
<section id="russian-roulette-2" class="level4">
<h4>Russian Roulette 2</h4>
<div class="named-code-block">
<p>«partial-reflection»</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> p <span class="op">=</span> <span class="dv">0.25</span> <span class="op">+</span> <span class="dv">0.5</span><span class="op">*</span>re<span class="op">;</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> rp <span class="op">=</span> re<span class="op">/</span>p<span class="op">;</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tp <span class="op">=</span> tr<span class="op">/</span>(<span class="dv">1</span><span class="op">.-</span>p)<span class="op">;</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> depth <span class="op">&gt;</span> <span class="dv">2</span> <span class="op">{</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> rng<span class="op">.</span><span class="pp">gen::</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span>() <span class="op">&lt;</span> p <span class="op">{</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>ray <span class="op">=</span> reflected_ray<span class="op">;</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>        colour <span class="op">=</span> f <span class="op">*</span> colour <span class="op">*</span> rp<span class="op">;</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>ray <span class="op">=</span> Ray <span class="op">{</span> origin<span class="op">:</span> x<span class="op">,</span> direction<span class="op">:</span> tdir <span class="op">};</span></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>        colour <span class="op">=</span> f <span class="op">*</span> colour <span class="op">*</span> tp<span class="op">;</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r <span class="op">=</span> radiance(<span class="op">&amp;</span><span class="kw">mut</span> Ray <span class="op">{</span>origin<span class="op">:</span> x<span class="op">,</span> direction<span class="op">:</span> tdir<span class="op">},</span> depth)<span class="op">;</span></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> output <span class="op">+</span> r <span class="op">*</span> f <span class="op">*</span> colour <span class="op">*</span> tr<span class="op">;</span></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>ray <span class="op">=</span> reflected_ray<span class="op">;</span></span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a>    colour <span class="op">=</span> f <span class="op">*</span> colour <span class="op">*</span> re<span class="op">;</span></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</section>
</section>
</section>
</section>
<section id="image" class="level1">
<h1>Image</h1>
<div class="named-code-block">
<p>«image»</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Image</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> width<span class="op">:</span> <span class="dt">usize</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> height<span class="op">:</span> <span class="dt">usize</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> <span class="kw">pub</span> data<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>RGBColour<span class="op">&gt;</span> <span class="op">}</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Image <span class="op">{</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> new(width<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> height<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> Image <span class="op">{</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>        Image <span class="op">{</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>            width<span class="op">:</span> width<span class="op">,</span> height<span class="op">:</span> height<span class="op">,</span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>            data<span class="op">:</span> <span class="pp">vec!</span>[BLACK<span class="op">;</span> width<span class="op">*</span>height]</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> for_each<span class="op">&lt;</span>F<span class="op">&gt;</span>(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> f<span class="op">:</span> F)</span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span> F<span class="op">:</span> <span class="bu">Send</span> <span class="op">+</span> <span class="bu">Sync</span> <span class="op">+</span> <span class="bu">Fn</span>(<span class="dt">usize</span><span class="op">,</span> <span class="dt">usize</span><span class="op">,</span> <span class="op">&amp;</span><span class="kw">mut</span> RGBColour)</span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">indicatif::</span>ParallelProgressIterator<span class="op">;</span></span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// use rayon::iter::{ParallelIterator, IntoParallelRefIterator};</span></span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> w <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>width<span class="op">;</span></span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> size <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>size() <span class="kw">as</span> <span class="dt">u64</span><span class="op">;</span></span>
<span id="cb57-22"><a href="#cb57-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>data</span>
<span id="cb57-23"><a href="#cb57-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>par_iter_mut()<span class="op">.</span>progress_count(size)</span>
<span id="cb57-24"><a href="#cb57-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>enumerate()</span>
<span id="cb57-25"><a href="#cb57-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>for_each(<span class="op">|</span>(i<span class="op">,</span> c)<span class="op">|</span> <span class="op">{</span></span>
<span id="cb57-26"><a href="#cb57-26" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> x <span class="op">=</span> i <span class="op">%</span> w<span class="op">;</span></span>
<span id="cb57-27"><a href="#cb57-27" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> y <span class="op">=</span> i <span class="op">/</span> w<span class="op">;</span></span>
<span id="cb57-28"><a href="#cb57-28" aria-hidden="true" tabindex="-1"></a>                f(x<span class="op">,</span> y<span class="op">,</span> c)<span class="op">;</span></span>
<span id="cb57-29"><a href="#cb57-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb57-30"><a href="#cb57-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-31"><a href="#cb57-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-32"><a href="#cb57-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> size(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">usize</span> <span class="op">{</span> <span class="kw">self</span><span class="op">.</span>width <span class="op">*</span> <span class="kw">self</span><span class="op">.</span>height <span class="op">}</span></span>
<span id="cb57-33"><a href="#cb57-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-34"><a href="#cb57-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>print<span class="op">-</span>ppm<span class="op">&gt;&gt;</span></span>
<span id="cb57-35"><a href="#cb57-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<section id="writing-to-ppm" class="level2">
<h2>Writing to PPM</h2>
<p>To write output efficiently, we need a <code>BufWriter</code> instance.</p>
<div class="named-code-block">
<p>«print-ppm»</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> print_ppm(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> path<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::fs::</span>File<span class="op">;</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::io::</span><span class="bu">Write</span><span class="op">;</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> file <span class="op">=</span> <span class="pp">File::</span>create(path)<span class="op">?;</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> out <span class="op">=</span> <span class="pp">std::io::BufWriter::</span>new(file)<span class="op">;</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">write!</span>(<span class="op">&amp;</span><span class="kw">mut</span> out<span class="op">,</span> <span class="st">&quot;P3</span><span class="sc">\n</span><span class="st">{} {}</span><span class="sc">\n</span><span class="st">{}</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">self</span><span class="op">.</span>width<span class="op">,</span> <span class="kw">self</span><span class="op">.</span>height<span class="op">,</span> <span class="dv">255</span>)<span class="op">?;</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> rgb <span class="kw">in</span> <span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>data <span class="op">{</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (r<span class="op">,</span> g<span class="op">,</span> b) <span class="op">=</span> rgb<span class="op">.</span>to_u24()<span class="op">;</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>        <span class="pp">write!</span>(<span class="op">&amp;</span><span class="kw">mut</span> out<span class="op">,</span> <span class="st">&quot;{} {} {} &quot;</span><span class="op">,</span> r<span class="op">,</span> g<span class="op">,</span> b)<span class="op">?;</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(())</span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</section>
</section>
<section id="main" class="level1">
<h1>Main</h1>
<div class="named-code-block">
<p>file:src/main.rs</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>import<span class="op">-</span>quickcheck<span class="op">&gt;&gt;</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>import<span class="op">-</span>rand<span class="op">&gt;&gt;</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>imports<span class="op">&gt;&gt;</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="kw">crate</span> indicatif<span class="op">;</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="kw">crate</span> argh<span class="op">;</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">argh::</span>FromArgs<span class="op">;</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a><span class="kw">mod</span> vec3<span class="op">;</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">vec3::</span><span class="op">*;</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a><span class="kw">mod</span> colour<span class="op">;</span></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">colour::</span><span class="op">*;</span></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>constants<span class="op">&gt;&gt;</span></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>ray<span class="op">&gt;&gt;</span></span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>material<span class="op">&gt;&gt;</span></span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>sphere<span class="op">&gt;&gt;</span></span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>scene<span class="op">&gt;&gt;</span></span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>path<span class="op">-</span>tracing<span class="op">&gt;&gt;</span></span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>image<span class="op">&gt;&gt;</span></span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-22"><a href="#cb59-22" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb59-23"><a href="#cb59-23" aria-hidden="true" tabindex="-1"></a><span class="kw">mod</span> tests <span class="op">{</span></span>
<span id="cb59-24"><a href="#cb59-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="kw">super</span><span class="pp">::</span><span class="op">*;</span></span>
<span id="cb59-25"><a href="#cb59-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">quickcheck::</span><span class="op">*;</span></span>
<span id="cb59-26"><a href="#cb59-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-27"><a href="#cb59-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>vector<span class="op">-</span>tests<span class="op">&gt;&gt;</span></span>
<span id="cb59-28"><a href="#cb59-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb59-29"><a href="#cb59-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-30"><a href="#cb59-30" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span>FromArgs<span class="at">)]</span></span>
<span id="cb59-31"><a href="#cb59-31" aria-hidden="true" tabindex="-1"></a><span class="co">/// Renders the Cornell box as interpreted by Kevin Beason&#39;s SmallPt</span></span>
<span id="cb59-32"><a href="#cb59-32" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Arghs <span class="op">{</span></span>
<span id="cb59-33"><a href="#cb59-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// optional sample size (100)</span></span>
<span id="cb59-34"><a href="#cb59-34" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>argh<span class="at">(</span>option<span class="op">,</span> short <span class="op">=</span> <span class="ch">&#39;s&#39;</span><span class="op">,</span> <span class="kw">default</span> <span class="op">=</span> <span class="st">&quot;SAMPLES&quot;</span><span class="at">)]</span></span>
<span id="cb59-35"><a href="#cb59-35" aria-hidden="true" tabindex="-1"></a>    samples<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb59-36"><a href="#cb59-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-37"><a href="#cb59-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// optional thread count</span></span>
<span id="cb59-38"><a href="#cb59-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// the default (0) will take the systems logical cpu count</span></span>
<span id="cb59-39"><a href="#cb59-39" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>argh<span class="at">(</span>option<span class="op">,</span> short <span class="op">=</span> <span class="ch">&#39;t&#39;</span><span class="op">,</span> <span class="kw">default</span> <span class="op">=</span> <span class="st">&quot;0&quot;</span><span class="at">)]</span></span>
<span id="cb59-40"><a href="#cb59-40" aria-hidden="true" tabindex="-1"></a>    threads<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb59-41"><a href="#cb59-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-42"><a href="#cb59-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// optional stack size in MB per thread</span></span>
<span id="cb59-43"><a href="#cb59-43" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>argh<span class="at">(</span>option<span class="op">,</span> short <span class="op">=</span> <span class="ch">&#39;z&#39;</span><span class="op">,</span> <span class="kw">default</span> <span class="op">=</span> <span class="st">&quot;8&quot;</span><span class="at">)]</span></span>
<span id="cb59-44"><a href="#cb59-44" aria-hidden="true" tabindex="-1"></a>    stack<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb59-45"><a href="#cb59-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-46"><a href="#cb59-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// optional image size dimensions WxH (640x480)</span></span>
<span id="cb59-47"><a href="#cb59-47" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>argh<span class="at">(</span>option<span class="op">,</span> from_str_fn<span class="at">(</span>into_plot_dimensions<span class="at">)</span><span class="op">,</span> <span class="kw">default</span> <span class="op">=</span> <span class="st">&quot;(WIDTH, HEIGHT)&quot;</span><span class="at">)]</span></span>
<span id="cb59-48"><a href="#cb59-48" aria-hidden="true" tabindex="-1"></a>    wxh<span class="op">:</span> (<span class="dt">usize</span><span class="op">,</span> <span class="dt">usize</span>)<span class="op">,</span></span>
<span id="cb59-49"><a href="#cb59-49" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb59-50"><a href="#cb59-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-51"><a href="#cb59-51" aria-hidden="true" tabindex="-1"></a><span class="co">// Helper function for parsing plot dimensions from command line arguments.</span></span>
<span id="cb59-52"><a href="#cb59-52" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> into_plot_dimensions(dim<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>(<span class="dt">usize</span><span class="op">,</span> <span class="dt">usize</span>)<span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb59-53"><a href="#cb59-53" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (w<span class="op">,</span> h) <span class="op">=</span> dim</span>
<span id="cb59-54"><a href="#cb59-54" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>split_once(<span class="ch">&#39;x&#39;</span>)</span>
<span id="cb59-55"><a href="#cb59-55" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>ok_or(<span class="st">&quot;dimensions do not parse, no delimiter?&quot;</span>)<span class="op">?;</span></span>
<span id="cb59-56"><a href="#cb59-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> w <span class="op">=</span> w<span class="op">.</span><span class="pp">parse::</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;</span>()<span class="op">.</span>map_err(<span class="op">|</span>e<span class="op">|</span> e<span class="op">.</span>to_string())<span class="op">?;</span></span>
<span id="cb59-57"><a href="#cb59-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> h <span class="op">=</span> h<span class="op">.</span><span class="pp">parse::</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;</span>()<span class="op">.</span>map_err(<span class="op">|</span>e<span class="op">|</span> e<span class="op">.</span>to_string())<span class="op">?;</span></span>
<span id="cb59-58"><a href="#cb59-58" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>((w<span class="op">,</span> h))</span>
<span id="cb59-59"><a href="#cb59-59" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb59-60"><a href="#cb59-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-61"><a href="#cb59-61" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb59-62"><a href="#cb59-62" aria-hidden="true" tabindex="-1"></a>    <span class="co">// use rayon::current_thread_index;</span></span>
<span id="cb59-63"><a href="#cb59-63" aria-hidden="true" tabindex="-1"></a>    <span class="co">// rayon::ThreadPoolBuilder::new().num_threads(4).build_global().unwrap();</span></span>
<span id="cb59-64"><a href="#cb59-64" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> args<span class="op">:</span> Arghs <span class="op">=</span> <span class="pp">argh::</span>from_env()<span class="op">;</span></span>
<span id="cb59-65"><a href="#cb59-65" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (w<span class="op">,</span> h) <span class="op">=</span> args<span class="op">.</span>wxh<span class="op">;</span></span>
<span id="cb59-66"><a href="#cb59-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> samps <span class="op">=</span> args<span class="op">.</span>samples <span class="op">/</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb59-67"><a href="#cb59-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-68"><a href="#cb59-68" aria-hidden="true" tabindex="-1"></a>    <span class="pp">rayon::ThreadPoolBuilder::</span>new()</span>
<span id="cb59-69"><a href="#cb59-69" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>num_threads(args<span class="op">.</span>threads)</span>
<span id="cb59-70"><a href="#cb59-70" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>stack_size(args<span class="op">.</span>stack <span class="op">*</span> <span class="dv">1024</span> <span class="op">*</span> <span class="dv">1024</span>)</span>
<span id="cb59-71"><a href="#cb59-71" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>build_global()</span>
<span id="cb59-72"><a href="#cb59-72" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb59-73"><a href="#cb59-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-74"><a href="#cb59-74" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> cam <span class="op">=</span> Ray <span class="op">{</span> origin<span class="op">:</span> vec(<span class="dv">50</span><span class="op">.,</span> <span class="dv">52</span><span class="op">.,</span> <span class="dv">295.6</span>)<span class="op">,</span> direction<span class="op">:</span> vec(<span class="dv">0.0</span><span class="op">,</span> <span class="op">-</span><span class="dv">0.045</span><span class="op">,</span> <span class="op">-</span><span class="dv">1.0</span>)<span class="op">.</span>normalize() <span class="op">};</span></span>
<span id="cb59-75"><a href="#cb59-75" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> cx <span class="op">=</span> vec(w <span class="kw">as</span> <span class="dt">f64</span> <span class="op">*</span> <span class="dv">0.510</span> <span class="op">/</span> h <span class="kw">as</span> <span class="dt">f64</span><span class="op">,</span> <span class="dv">0</span><span class="op">.,</span> <span class="dv">0</span><span class="op">.</span>)<span class="op">;</span></span>
<span id="cb59-76"><a href="#cb59-76" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> cy <span class="op">=</span> (cx <span class="op">%</span> cam<span class="op">.</span>direction)<span class="op">.</span>normalize() <span class="op">*</span> <span class="dv">0.510</span><span class="op">;</span></span>
<span id="cb59-77"><a href="#cb59-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-78"><a href="#cb59-78" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> img <span class="op">=</span> <span class="pp">Image::</span>new(w<span class="op">,</span> h)<span class="op">;</span></span>
<span id="cb59-79"><a href="#cb59-79" aria-hidden="true" tabindex="-1"></a>    <span class="pp">eprintln!</span>(<span class="st">&quot;Rendering ({} spp)&quot;</span><span class="op">,</span> samps<span class="op">*</span><span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb59-80"><a href="#cb59-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-81"><a href="#cb59-81" aria-hidden="true" tabindex="-1"></a>    img<span class="op">.</span>for_each(<span class="op">|</span>x<span class="op">,</span> y<span class="op">,</span> c<span class="op">|</span> <span class="op">{</span></span>
<span id="cb59-82"><a href="#cb59-82" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> rng <span class="op">=</span> <span class="pp">rand::</span>thread_rng()<span class="op">;</span></span>
<span id="cb59-83"><a href="#cb59-83" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> sy <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">2</span> <span class="op">{</span></span>
<span id="cb59-84"><a href="#cb59-84" aria-hidden="true" tabindex="-1"></a>            <span class="kw">for</span> sx <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">2</span> <span class="op">{</span></span>
<span id="cb59-85"><a href="#cb59-85" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> <span class="kw">mut</span> r <span class="op">=</span> BLACK<span class="op">.</span>clone()<span class="op">;</span></span>
<span id="cb59-86"><a href="#cb59-86" aria-hidden="true" tabindex="-1"></a>                <span class="kw">for</span> _ <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span>samps <span class="op">{</span></span>
<span id="cb59-87"><a href="#cb59-87" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> r1 <span class="op">=</span> <span class="dv">2</span><span class="op">.</span> <span class="op">*</span> rng<span class="op">.</span><span class="pp">gen::</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span>()<span class="op">;</span></span>
<span id="cb59-88"><a href="#cb59-88" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> dx <span class="op">=</span> <span class="kw">if</span> r1 <span class="op">&lt;</span> <span class="dv">1</span><span class="op">.</span> <span class="op">{</span> r1<span class="op">.</span>sqrt() <span class="op">-</span> <span class="dv">1</span><span class="op">.</span> <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> <span class="dv">1</span><span class="op">.</span> <span class="op">-</span> (<span class="dv">2</span><span class="op">.</span> <span class="op">-</span> r1)<span class="op">.</span>sqrt() <span class="op">};</span></span>
<span id="cb59-89"><a href="#cb59-89" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> r2 <span class="op">=</span> <span class="dv">2</span><span class="op">.</span> <span class="op">*</span> rng<span class="op">.</span><span class="pp">gen::</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span>()<span class="op">;</span></span>
<span id="cb59-90"><a href="#cb59-90" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> dy <span class="op">=</span> <span class="kw">if</span> r2 <span class="op">&lt;</span> <span class="dv">1</span><span class="op">.</span> <span class="op">{</span> r2<span class="op">.</span>sqrt() <span class="op">-</span> <span class="dv">1</span><span class="op">.</span> <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> <span class="dv">1</span><span class="op">.</span> <span class="op">-</span> (<span class="dv">2</span><span class="op">.</span> <span class="op">-</span> r2)<span class="op">.</span>sqrt() <span class="op">};</span></span>
<span id="cb59-91"><a href="#cb59-91" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> d <span class="op">=</span> cx<span class="op">*</span>( ( (sx <span class="kw">as</span> <span class="dt">f64</span> <span class="op">+</span> <span class="dv">0.5</span> <span class="op">+</span> dx) <span class="op">/</span> <span class="dv">2</span><span class="op">.</span> <span class="op">+</span> x <span class="kw">as</span> <span class="dt">f64</span>) <span class="op">/</span> w <span class="kw">as</span> <span class="dt">f64</span> <span class="op">-</span> <span class="dv">0.5</span> )</span>
<span id="cb59-92"><a href="#cb59-92" aria-hidden="true" tabindex="-1"></a>                          <span class="op">+</span> cy<span class="op">*</span>( ( (sy <span class="kw">as</span> <span class="dt">f64</span> <span class="op">+</span> <span class="dv">0.5</span> <span class="op">+</span> dy) <span class="op">/</span> <span class="dv">2</span><span class="op">.</span> <span class="op">+</span> (h <span class="op">-</span> y <span class="op">-</span> <span class="dv">1</span>) <span class="kw">as</span> <span class="dt">f64</span>) <span class="op">/</span> h <span class="kw">as</span> <span class="dt">f64</span> <span class="op">-</span> <span class="dv">0.5</span> )</span>
<span id="cb59-93"><a href="#cb59-93" aria-hidden="true" tabindex="-1"></a>                          <span class="op">+</span> cam<span class="op">.</span>direction<span class="op">;</span></span>
<span id="cb59-94"><a href="#cb59-94" aria-hidden="true" tabindex="-1"></a>                    r <span class="op">=</span> r <span class="op">+</span> radiance(<span class="op">&amp;</span><span class="kw">mut</span> Ray <span class="op">{</span>origin<span class="op">:</span> cam<span class="op">.</span>origin <span class="op">+</span> d<span class="op">*</span><span class="dv">140</span><span class="op">.,</span> direction<span class="op">:</span> d<span class="op">.</span>normalize()<span class="op">},</span> <span class="dv">0</span>) <span class="op">*</span> (<span class="dv">1</span><span class="op">./</span>samps <span class="kw">as</span> <span class="dt">f64</span>)<span class="op">;</span></span>
<span id="cb59-95"><a href="#cb59-95" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb59-96"><a href="#cb59-96" aria-hidden="true" tabindex="-1"></a>                <span class="op">*</span>c <span class="op">=</span> <span class="op">*</span>c <span class="op">+</span> r<span class="op">.</span>clamp() <span class="op">*</span> <span class="dv">0.25</span><span class="op">;</span></span>
<span id="cb59-97"><a href="#cb59-97" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb59-98"><a href="#cb59-98" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb59-99"><a href="#cb59-99" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb59-100"><a href="#cb59-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-101"><a href="#cb59-101" aria-hidden="true" tabindex="-1"></a>    <span class="pp">eprintln!</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">Writing image.&quot;</span>)<span class="op">;</span></span>
<span id="cb59-102"><a href="#cb59-102" aria-hidden="true" tabindex="-1"></a>    img<span class="op">.</span>print_ppm(<span class="st">&quot;image_rust.ppm&quot;</span>)</span>
<span id="cb59-103"><a href="#cb59-103" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</section>
        </div>
         <div class="col-3 col-s-3 menu" id="menu-container">
                <div id="menu"><nav id="TOC" role="doc-toc">
                                <ul>
                                <li><a href="#literatept">LiteratePT</a></li>
                                <li><a href="#vectors">Vectors</a>
                                <ul>
                                <li><a href="#tests">Tests</a></li>
                                </ul></li>
                                <li><a href="#colour">Colour</a></li>
                                <li><a href="#geometry">Geometry</a></li>
                                <li><a href="#scene">Scene</a></li>
                                <li><a href="#path-tracing">Path tracing</a>
                                <ul>
                                <li><a href="#russian-roulette-1">Russian Roulette 1</a></li>
                                <li><a href="#normals">Normals</a></li>
                                <li><a href="#reflection">Reflection</a></li>
                                </ul></li>
                                <li><a href="#image">Image</a>
                                <ul>
                                <li><a href="#writing-to-ppm">Writing to PPM</a></li>
                                </ul></li>
                                <li><a href="#main">Main</a></li>
                                </ul>
                </nav></div>
        </div> 
</div>
<div class="footer">
</div>
<!-- <script>
function toggle_dark_mode() {
    var app = document.getElementsByTagName("BODY")[0];
    if (localStorage.darkMode == "dark") {
	localStorage.darkMode = "light";
	app.setAttribute("dark-mode", "light");
    } else {
	localStorage.darkMode = "dark";
	app.setAttribute("dark-mode", "dark");
    }
}
</script> -->
</body>
</html>
